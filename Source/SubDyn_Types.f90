!STARTOFREGISTRYGENERATEDFILE './SubDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
!*********************************************************************************************************************************
! SubDyn_Types
!.................................................................................................................................
! LICENSING
! Copyright (C) 2012 National Renewable Energy Laboratory
!
! This file is part of SubDyn.
!
! SubDyn is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along with ModuleName.
! If not, see <http://www.gnu.org/licenses/>.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE SubDyn_Types
! This module contains all of the user-defined types needed in SubDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
  TYPE, PUBLIC :: MeshAuxDataType
    INTEGER(IntKi)  :: MemberID 
    INTEGER(IntKi)  :: NOutCnt 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeCnt 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeIDs 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmIDs 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmNds 
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmID2s 
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmNd2s 
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Me 
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Ke 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Fg 
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Me2 
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Ke2 
    REAL(ReKi) , DIMENSION(1:12,1:2)  :: Fg2 
  END TYPE MeshAuxDataType
  TYPE, PUBLIC :: ElemPropType
    REAL(ReKi)  :: Area 
    REAL(ReKi)  :: Length 
    REAL(ReKi)  :: Ixx 
    REAL(ReKi)  :: Iyy 
    REAL(ReKi)  :: Jzz 
    LOGICAL  :: Shear 
    REAL(ReKi)  :: Kappa 
    REAL(ReKi)  :: YoungE 
    REAL(ReKi)  :: ShearG 
    REAL(ReKi)  :: Rho 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: DirCos 
  END TYPE ElemPropType
  TYPE, PUBLIC :: SD_InitInputType
    CHARACTER(1024)  :: SDInputFile 
    REAL(ReKi)  :: g 
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint 
    CHARACTER(1024)  :: SubDynSum 
    CHARACTER(1024)  :: RootName 
    REAL(ReKi)  :: DT 
    INTEGER(IntKi)  :: ErrStat 
    INTEGER(IntKi)  :: NJoints 
    INTEGER(IntKi)  :: JointsCol = 4 
    INTEGER(IntKi)  :: MembersCol = 5 
    INTEGER(IntKi)  :: NPropSets 
    INTEGER(IntKi)  :: PropSetsCol = 6 
    INTEGER(IntKi)  :: NXPropSets 
    INTEGER(IntKi)  :: XPropSetsCol = 10 
    INTEGER(IntKi)  :: ReactCol = 7 
    INTEGER(IntKi)  :: NInterf 
    INTEGER(IntKi)  :: InterfCol = 7 
    INTEGER(IntKi)  :: NCMass 
    INTEGER(IntKi)  :: CMassCol = 5 
    INTEGER(IntKi)  :: NCOSMs 
    INTEGER(IntKi)  :: COSMsCol = 10 
    INTEGER(IntKi)  :: FEMMod 
    INTEGER(IntKi)  :: NDiv 
    LOGICAL  :: CBMod 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Joints 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSets 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XPropSets 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: COSMs 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CMass 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: JDampings 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Members 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Interf 
    INTEGER(IntKi)  :: NNode 
    INTEGER(IntKi)  :: NElem 
    INTEGER(IntKi)  :: NProp 
    INTEGER(IntKi)  :: TDOF 
    INTEGER(IntKi)  :: MaxMemJnt = 10 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Props 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: K 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: M 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FG 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ElemProps 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: BCs 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: IntFc 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: MemberNodes 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnN 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnE 
  END TYPE SD_InitInputType
  TYPE, PUBLIC :: SD_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt 
    INTEGER(IntKi)  :: MaxOutChs = 2000 
    LOGICAL  :: TabDelim 
    LOGICAL  :: OutCOSM 
    LOGICAL  :: SSSum 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: SSOutList 
  END TYPE SD_InitOutputType
  TYPE, PUBLIC :: SD_ContinuousStateType
    REAL(ReKi)  :: DummyContState 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qm 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdotdot 
  END TYPE SD_ContinuousStateType
  TYPE, PUBLIC :: SD_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState 
  END TYPE SD_DiscreteStateType
  TYPE, PUBLIC :: SD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState 
  END TYPE SD_ConstraintStateType
  TYPE, PUBLIC :: SD_OtherStateType
    TYPE(SD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: xdot 
    INTEGER(IntKi)  :: n 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Udotdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y2 
  END TYPE SD_OtherStateType
  TYPE, PUBLIC :: SD_OutVar_Type
    INTEGER(IntKi)  :: Indx 
    INTEGER(IntKi)  :: SignM 
    CHARACTER(10)  :: Units 
    CHARACTER(10)  :: Name 
  END TYPE SD_OutVar_Type
  TYPE, PUBLIC :: SD_ParameterType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A_22 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: B_23 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: B_24 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_11 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_12 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_11 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_13 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_14 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FY 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_42 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_11 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_32 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_42 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Abar_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Abar_22 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Bbar_13 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Bbar_23 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Bbar_24 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Fbar_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBB 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KBB 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBM 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PHI_R 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PHI_M 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TIreact 
    INTEGER(IntKi)  :: NModes 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Elems 
    INTEGER(IntKi)  :: qmL 
    INTEGER(IntKi)  :: uL 
    INTEGER(IntKi)  :: DofL 
    INTEGER(IntKi)  :: NNodes_L 
    INTEGER(IntKi)  :: DofI 
    INTEGER(IntKi)  :: DofR 
    INTEGER(IntKi)  :: DofC 
    INTEGER(IntKi)  :: NReact 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Reacts 
    INTEGER(IntKi)  :: Nmembers 
    INTEGER(IntKi)  :: TPdofL = 6 
    INTEGER(IntKi)  :: URbarL 
    INTEGER(IntKi)  :: URdotdotL 
    INTEGER(IntKi)  :: UdotdotL 
    INTEGER(IntKi)  :: Y2L 
    INTEGER(IntKi)  :: IntMethod 
    INTEGER(IntKi)  :: NAvgEls = 2 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDI 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDR 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDL 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDY 
    INTEGER(IntKi)  :: NMOutputs 
    INTEGER(IntKi)  :: NumOuts 
    REAL(ReKi)  :: SDDeltaT 
    INTEGER(IntKi)  :: OutSwtch 
    INTEGER(IntKi)  :: UnJckF 
    CHARACTER(1)  :: Delim 
    CHARACTER(20)  :: OutFmt 
    CHARACTER(20)  :: OutSFmt 
    CHARACTER(1024)  :: OutJckF 
    CHARACTER(1024)  :: JEchoFile 
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst 
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst2 
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst3 
    TYPE(ElemPropType) , DIMENSION(:), ALLOCATABLE  :: ElemProps 
    TYPE(SD_OutVar_Type) , DIMENSION(:), ALLOCATABLE  :: OutParam 
    LOGICAL  :: OutAll 
    LOGICAL  :: OutReact 
    INTEGER(IntKi)  :: OutAllInt 
    INTEGER(IntKi)  :: OutAllDims 
    INTEGER(IntKi)  :: OutDec 
    INTEGER(IntKi)  :: MaxOUtPts 
  END TYPE SD_ParameterType
  TYPE, PUBLIC :: SD_InputType
    TYPE(MeshType)  :: TPMesh 
    TYPE(MeshType)  :: LMesh 
  END TYPE SD_InputType
  TYPE, PUBLIC :: SD_OutputType
    TYPE(MeshType)  :: Y1Mesh 
    TYPE(MeshType)  :: Y2Mesh 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput 
  END TYPE SD_OutputType
  TYPE, PUBLIC :: SD_PartialOutputPInputType
    TYPE(SD_InputType)  :: DummyOutput 
  END TYPE SD_PartialOutputPInputType
  TYPE, PUBLIC :: SD_PartialContStatePInputType
    TYPE(SD_InputType)  :: DummyContState 
  END TYPE SD_PartialContStatePInputType
  TYPE, PUBLIC :: SD_PartialDiscStatePInputType
    TYPE(SD_InputType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePInputType
  TYPE, PUBLIC :: SD_PartialConstrStatePInputType
    TYPE(SD_InputType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePInputType
  TYPE, PUBLIC :: SD_PartialOutputPContStateType
    TYPE(SD_ContinuousStateType)  :: DummyOutput 
  END TYPE SD_PartialOutputPContStateType
  TYPE, PUBLIC :: SD_PartialContStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyContState 
  END TYPE SD_PartialContStatePContStateType
  TYPE, PUBLIC :: SD_PartialDiscStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePContStateType
  TYPE, PUBLIC :: SD_PartialConstrStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePContStateType
  TYPE, PUBLIC :: SD_PartialOutputPDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyOutput 
  END TYPE SD_PartialOutputPDiscStateType
  TYPE, PUBLIC :: SD_PartialContStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyContState 
  END TYPE SD_PartialContStatePDiscStateType
  TYPE, PUBLIC :: SD_PartialDiscStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePDiscStateType
  TYPE, PUBLIC :: SD_PartialConstrStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePDiscStateType
  TYPE, PUBLIC :: SD_PartialOutputPConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyOutput 
  END TYPE SD_PartialOutputPConstrStateType
  TYPE, PUBLIC :: SD_PartialContStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyContState 
  END TYPE SD_PartialContStatePConstrStateType
  TYPE, PUBLIC :: SD_PartialDiscStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePConstrStateType
  TYPE, PUBLIC :: SD_PartialConstrStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePConstrStateType
CONTAINS
 SUBROUTINE SD_Copymeshauxdatatype( SrcmeshauxdatatypeData, DstmeshauxdatatypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(meshauxdatatype), INTENT(INOUT) :: SrcmeshauxdatatypeData
  TYPE(meshauxdatatype), INTENT(INOUT) :: DstmeshauxdatatypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstmeshauxdatatypeData%MemberID = SrcmeshauxdatatypeData%MemberID
  DstmeshauxdatatypeData%NOutCnt = SrcmeshauxdatatypeData%NOutCnt
IF ( ALLOCATED( SrcmeshauxdatatypeData%NodeCnt ) ) THEN
  i1 = SIZE(SrcmeshauxdatatypeData%NodeCnt,1)
  IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%NodeCnt)) ALLOCATE(DstmeshauxdatatypeData%NodeCnt(i1))
  DstmeshauxdatatypeData%NodeCnt = SrcmeshauxdatatypeData%NodeCnt
ENDIF
IF ( ALLOCATED( SrcmeshauxdatatypeData%NodeIDs ) ) THEN
  i1 = SIZE(SrcmeshauxdatatypeData%NodeIDs,1)
  IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%NodeIDs)) ALLOCATE(DstmeshauxdatatypeData%NodeIDs(i1))
  DstmeshauxdatatypeData%NodeIDs = SrcmeshauxdatatypeData%NodeIDs
ENDIF
IF ( ALLOCATED( SrcmeshauxdatatypeData%ElmIDs ) ) THEN
  i1 = SIZE(SrcmeshauxdatatypeData%ElmIDs,1)
  i2 = SIZE(SrcmeshauxdatatypeData%ElmIDs,2)
  IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%ElmIDs)) ALLOCATE(DstmeshauxdatatypeData%ElmIDs(i1,i2))
  DstmeshauxdatatypeData%ElmIDs = SrcmeshauxdatatypeData%ElmIDs
ENDIF
IF ( ALLOCATED( SrcmeshauxdatatypeData%ElmNds ) ) THEN
  i1 = SIZE(SrcmeshauxdatatypeData%ElmNds,1)
  i2 = SIZE(SrcmeshauxdatatypeData%ElmNds,2)
  IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%ElmNds)) ALLOCATE(DstmeshauxdatatypeData%ElmNds(i1,i2))
  DstmeshauxdatatypeData%ElmNds = SrcmeshauxdatatypeData%ElmNds
ENDIF
  DstmeshauxdatatypeData%ElmID2s = SrcmeshauxdatatypeData%ElmID2s
  DstmeshauxdatatypeData%ElmNd2s = SrcmeshauxdatatypeData%ElmNd2s
IF ( ALLOCATED( SrcmeshauxdatatypeData%Me ) ) THEN
  i1 = SIZE(SrcmeshauxdatatypeData%Me,1)
  i2 = SIZE(SrcmeshauxdatatypeData%Me,2)
  i3 = SIZE(SrcmeshauxdatatypeData%Me,3)
  i4 = SIZE(SrcmeshauxdatatypeData%Me,4)
  IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%Me)) ALLOCATE(DstmeshauxdatatypeData%Me(i1,i2,i3,i4))
  DstmeshauxdatatypeData%Me = SrcmeshauxdatatypeData%Me
ENDIF
IF ( ALLOCATED( SrcmeshauxdatatypeData%Ke ) ) THEN
  i1 = SIZE(SrcmeshauxdatatypeData%Ke,1)
  i2 = SIZE(SrcmeshauxdatatypeData%Ke,2)
  i3 = SIZE(SrcmeshauxdatatypeData%Ke,3)
  i4 = SIZE(SrcmeshauxdatatypeData%Ke,4)
  IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%Ke)) ALLOCATE(DstmeshauxdatatypeData%Ke(i1,i2,i3,i4))
  DstmeshauxdatatypeData%Ke = SrcmeshauxdatatypeData%Ke
ENDIF
IF ( ALLOCATED( SrcmeshauxdatatypeData%Fg ) ) THEN
  i1 = SIZE(SrcmeshauxdatatypeData%Fg,1)
  i2 = SIZE(SrcmeshauxdatatypeData%Fg,2)
  i3 = SIZE(SrcmeshauxdatatypeData%Fg,3)
  IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%Fg)) ALLOCATE(DstmeshauxdatatypeData%Fg(i1,i2,i3))
  DstmeshauxdatatypeData%Fg = SrcmeshauxdatatypeData%Fg
ENDIF
  DstmeshauxdatatypeData%Me2 = SrcmeshauxdatatypeData%Me2
  DstmeshauxdatatypeData%Ke2 = SrcmeshauxdatatypeData%Ke2
  DstmeshauxdatatypeData%Fg2 = SrcmeshauxdatatypeData%Fg2
 END SUBROUTINE SD_Copymeshauxdatatype

 SUBROUTINE SD_Destroymeshauxdatatype( meshauxdatatypeData, ErrStat, ErrMsg )
  TYPE(meshauxdatatype), INTENT(INOUT) :: meshauxdatatypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(meshauxdatatypeData%NodeCnt) ) DEALLOCATE(meshauxdatatypeData%NodeCnt)
  IF ( ALLOCATED(meshauxdatatypeData%NodeIDs) ) DEALLOCATE(meshauxdatatypeData%NodeIDs)
  IF ( ALLOCATED(meshauxdatatypeData%ElmIDs) ) DEALLOCATE(meshauxdatatypeData%ElmIDs)
  IF ( ALLOCATED(meshauxdatatypeData%ElmNds) ) DEALLOCATE(meshauxdatatypeData%ElmNds)
  IF ( ALLOCATED(meshauxdatatypeData%Me) ) DEALLOCATE(meshauxdatatypeData%Me)
  IF ( ALLOCATED(meshauxdatatypeData%Ke) ) DEALLOCATE(meshauxdatatypeData%Ke)
  IF ( ALLOCATED(meshauxdatatypeData%Fg) ) DEALLOCATE(meshauxdatatypeData%Fg)
 END SUBROUTINE SD_Destroymeshauxdatatype

 SUBROUTINE SD_Packmeshauxdatatype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(meshauxdatatype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MemberID
  Int_BufSz  = Int_BufSz  + 1  ! NOutCnt
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodeCnt )  ! NodeCnt 
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodeIDs )  ! NodeIDs 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmIDs )  ! ElmIDs 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNds )  ! ElmNds 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmID2s )  ! ElmID2s 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNd2s )  ! ElmNd2s 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Me )  ! Me 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ke )  ! Ke 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fg )  ! Fg 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Me2 )  ! Me2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ke2 )  ! Ke2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fg2 )  ! Fg2 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NOutCnt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NodeCnt) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeCnt))-1 ) = PACK(InData%NodeCnt ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(InData%NodeIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeIDs))-1 ) = PACK(InData%NodeIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmIDs))-1 ) = PACK(InData%ElmIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmNds) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNds))-1 ) = PACK(InData%ElmNds ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNds)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmID2s))-1 ) = PACK(InData%ElmID2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmID2s)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNd2s))-1 ) = PACK(InData%ElmNd2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNd2s)
  IF ( ALLOCATED(InData%Me) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me))-1 ) =  PACK(InData%Me ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Me)
  ENDIF
  IF ( ALLOCATED(InData%Ke) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke))-1 ) =  PACK(InData%Ke ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Ke)
  ENDIF
  IF ( ALLOCATED(InData%Fg) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg))-1 ) =  PACK(InData%Fg ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fg)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me2))-1 ) =  PACK(InData%Me2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Me2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke2))-1 ) =  PACK(InData%Ke2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Ke2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg2))-1 ) =  PACK(InData%Fg2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Fg2)
 END SUBROUTINE SD_Packmeshauxdatatype

 SUBROUTINE SD_Unpackmeshauxdatatype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(meshauxdatatype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MemberID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NOutCnt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NodeCnt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeCnt,1))); mask1 = .TRUE.
    OutData%NodeCnt = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeCnt))-1 ),mask1,OutData%NodeCnt)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(OutData%NodeIDs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeIDs,1))); mask1 = .TRUE.
    OutData%NodeIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeIDs))-1 ),mask1,OutData%NodeIDs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmIDs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmIDs,1),SIZE(OutData%ElmIDs,2))); mask2 = .TRUE.
    OutData%ElmIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmIDs))-1 ),mask2,OutData%ElmIDs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmNds) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmNds,1),SIZE(OutData%ElmNds,2))); mask2 = .TRUE.
    OutData%ElmNds = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNds))-1 ),mask2,OutData%ElmNds)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNds)
  ENDIF
  ALLOCATE(mask1(SIZE(OutData%ElmID2s,1))); mask1 = .TRUE.
  OutData%ElmID2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmID2s))-1 ),mask1,OutData%ElmID2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmID2s)
  ALLOCATE(mask1(SIZE(OutData%ElmNd2s,1))); mask1 = .TRUE.
  OutData%ElmNd2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNd2s))-1 ),mask1,OutData%ElmNd2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNd2s)
  IF ( ALLOCATED(OutData%Me) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Me,1),SIZE(OutData%Me,2),SIZE(OutData%Me,3),SIZE(OutData%Me,4))); mask4 = .TRUE.
    OutData%Me = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me))-1 ),mask4,OutData%Me)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Me)
  ENDIF
  IF ( ALLOCATED(OutData%Ke) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Ke,1),SIZE(OutData%Ke,2),SIZE(OutData%Ke,3),SIZE(OutData%Ke,4))); mask4 = .TRUE.
    OutData%Ke = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke))-1 ),mask4,OutData%Ke)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke)
  ENDIF
  IF ( ALLOCATED(OutData%Fg) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Fg,1),SIZE(OutData%Fg,2),SIZE(OutData%Fg,3))); mask3 = .TRUE.
    OutData%Fg = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg))-1 ),mask3,OutData%Fg)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg)
  ENDIF
  ALLOCATE(mask3(SIZE(OutData%Me2,1),SIZE(OutData%Me2,2),SIZE(OutData%Me2,3))); mask3 = .TRUE.
  OutData%Me2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me2))-1 ),mask3,OutData%Me2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Me2)
  ALLOCATE(mask3(SIZE(OutData%Ke2,1),SIZE(OutData%Ke2,2),SIZE(OutData%Ke2,3))); mask3 = .TRUE.
  OutData%Ke2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke2))-1 ),mask3,OutData%Ke2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke2)
  ALLOCATE(mask2(SIZE(OutData%Fg2,1),SIZE(OutData%Fg2,2))); mask2 = .TRUE.
  OutData%Fg2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg2))-1 ),mask2,OutData%Fg2)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg2)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackmeshauxdatatype

 SUBROUTINE SD_Copyelemproptype( SrcelemproptypeData, DstelemproptypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(elemproptype), INTENT(INOUT) :: SrcelemproptypeData
  TYPE(elemproptype), INTENT(INOUT) :: DstelemproptypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstelemproptypeData%Area = SrcelemproptypeData%Area
  DstelemproptypeData%Length = SrcelemproptypeData%Length
  DstelemproptypeData%Ixx = SrcelemproptypeData%Ixx
  DstelemproptypeData%Iyy = SrcelemproptypeData%Iyy
  DstelemproptypeData%Jzz = SrcelemproptypeData%Jzz
  DstelemproptypeData%Shear = SrcelemproptypeData%Shear
  DstelemproptypeData%Kappa = SrcelemproptypeData%Kappa
  DstelemproptypeData%YoungE = SrcelemproptypeData%YoungE
  DstelemproptypeData%ShearG = SrcelemproptypeData%ShearG
  DstelemproptypeData%Rho = SrcelemproptypeData%Rho
  DstelemproptypeData%DirCos = SrcelemproptypeData%DirCos
 END SUBROUTINE SD_Copyelemproptype

 SUBROUTINE SD_Destroyelemproptype( elemproptypeData, ErrStat, ErrMsg )
  TYPE(elemproptype), INTENT(INOUT) :: elemproptypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_Destroyelemproptype

 SUBROUTINE SD_Packelemproptype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(elemproptype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Area
  Re_BufSz   = Re_BufSz   + 1  ! Length
  Re_BufSz   = Re_BufSz   + 1  ! Ixx
  Re_BufSz   = Re_BufSz   + 1  ! Iyy
  Re_BufSz   = Re_BufSz   + 1  ! Jzz
  Re_BufSz   = Re_BufSz   + 1  ! Kappa
  Re_BufSz   = Re_BufSz   + 1  ! YoungE
  Re_BufSz   = Re_BufSz   + 1  ! ShearG
  Re_BufSz   = Re_BufSz   + 1  ! Rho
  Re_BufSz    = Re_BufSz    + SIZE( InData%DirCos )  ! DirCos 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Area )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Length )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ixx )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Iyy )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Jzz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Kappa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YoungE )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ShearG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Rho )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DirCos))-1 ) =  PACK(InData%DirCos ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DirCos)
 END SUBROUTINE SD_Packelemproptype

 SUBROUTINE SD_Unpackelemproptype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(elemproptype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Area = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Length = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ixx = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Iyy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Jzz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Kappa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YoungE = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ShearG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Rho = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%DirCos,1),SIZE(OutData%DirCos,2))); mask2 = .TRUE.
  OutData%DirCos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DirCos))-1 ),mask2,OutData%DirCos)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DirCos)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackelemproptype

 SUBROUTINE SD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_initinputtype), INTENT(INOUT) :: SrcInitInputData
  TYPE(SD_initinputtype), INTENT(INOUT) :: DstInitInputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstInitInputData%SDInputFile = SrcInitInputData%SDInputFile
  DstInitInputData%g = SrcInitInputData%g
  DstInitInputData%TP_RefPoint = SrcInitInputData%TP_RefPoint
  DstInitInputData%SubDynSum = SrcInitInputData%SubDynSum
  DstInitInputData%RootName = SrcInitInputData%RootName
  DstInitInputData%DT = SrcInitInputData%DT
  DstInitInputData%ErrStat = SrcInitInputData%ErrStat
  DstInitInputData%NJoints = SrcInitInputData%NJoints
  DstInitInputData%JointsCol = SrcInitInputData%JointsCol
  DstInitInputData%MembersCol = SrcInitInputData%MembersCol
  DstInitInputData%NPropSets = SrcInitInputData%NPropSets
  DstInitInputData%PropSetsCol = SrcInitInputData%PropSetsCol
  DstInitInputData%NXPropSets = SrcInitInputData%NXPropSets
  DstInitInputData%XPropSetsCol = SrcInitInputData%XPropSetsCol
  DstInitInputData%ReactCol = SrcInitInputData%ReactCol
  DstInitInputData%NInterf = SrcInitInputData%NInterf
  DstInitInputData%InterfCol = SrcInitInputData%InterfCol
  DstInitInputData%NCMass = SrcInitInputData%NCMass
  DstInitInputData%CMassCol = SrcInitInputData%CMassCol
  DstInitInputData%NCOSMs = SrcInitInputData%NCOSMs
  DstInitInputData%COSMsCol = SrcInitInputData%COSMsCol
  DstInitInputData%FEMMod = SrcInitInputData%FEMMod
  DstInitInputData%NDiv = SrcInitInputData%NDiv
  DstInitInputData%CBMod = SrcInitInputData%CBMod
IF ( ALLOCATED( SrcInitInputData%Joints ) ) THEN
  i1 = SIZE(SrcInitInputData%Joints,1)
  i2 = SIZE(SrcInitInputData%Joints,2)
  IF (.NOT.ALLOCATED(DstInitInputData%Joints)) ALLOCATE(DstInitInputData%Joints(i1,i2))
  DstInitInputData%Joints = SrcInitInputData%Joints
ENDIF
IF ( ALLOCATED( SrcInitInputData%PropSets ) ) THEN
  i1 = SIZE(SrcInitInputData%PropSets,1)
  i2 = SIZE(SrcInitInputData%PropSets,2)
  IF (.NOT.ALLOCATED(DstInitInputData%PropSets)) ALLOCATE(DstInitInputData%PropSets(i1,i2))
  DstInitInputData%PropSets = SrcInitInputData%PropSets
ENDIF
IF ( ALLOCATED( SrcInitInputData%XPropSets ) ) THEN
  i1 = SIZE(SrcInitInputData%XPropSets,1)
  i2 = SIZE(SrcInitInputData%XPropSets,2)
  IF (.NOT.ALLOCATED(DstInitInputData%XPropSets)) ALLOCATE(DstInitInputData%XPropSets(i1,i2))
  DstInitInputData%XPropSets = SrcInitInputData%XPropSets
ENDIF
IF ( ALLOCATED( SrcInitInputData%COSMs ) ) THEN
  i1 = SIZE(SrcInitInputData%COSMs,1)
  i2 = SIZE(SrcInitInputData%COSMs,2)
  IF (.NOT.ALLOCATED(DstInitInputData%COSMs)) ALLOCATE(DstInitInputData%COSMs(i1,i2))
  DstInitInputData%COSMs = SrcInitInputData%COSMs
ENDIF
IF ( ALLOCATED( SrcInitInputData%CMass ) ) THEN
  i1 = SIZE(SrcInitInputData%CMass,1)
  i2 = SIZE(SrcInitInputData%CMass,2)
  IF (.NOT.ALLOCATED(DstInitInputData%CMass)) ALLOCATE(DstInitInputData%CMass(i1,i2))
  DstInitInputData%CMass = SrcInitInputData%CMass
ENDIF
IF ( ALLOCATED( SrcInitInputData%JDampings ) ) THEN
  i1 = SIZE(SrcInitInputData%JDampings,1)
  IF (.NOT.ALLOCATED(DstInitInputData%JDampings)) ALLOCATE(DstInitInputData%JDampings(i1))
  DstInitInputData%JDampings = SrcInitInputData%JDampings
ENDIF
IF ( ALLOCATED( SrcInitInputData%Members ) ) THEN
  i1 = SIZE(SrcInitInputData%Members,1)
  i2 = SIZE(SrcInitInputData%Members,2)
  IF (.NOT.ALLOCATED(DstInitInputData%Members)) ALLOCATE(DstInitInputData%Members(i1,i2))
  DstInitInputData%Members = SrcInitInputData%Members
ENDIF
IF ( ALLOCATED( SrcInitInputData%Interf ) ) THEN
  i1 = SIZE(SrcInitInputData%Interf,1)
  i2 = SIZE(SrcInitInputData%Interf,2)
  IF (.NOT.ALLOCATED(DstInitInputData%Interf)) ALLOCATE(DstInitInputData%Interf(i1,i2))
  DstInitInputData%Interf = SrcInitInputData%Interf
ENDIF
  DstInitInputData%NNode = SrcInitInputData%NNode
  DstInitInputData%NElem = SrcInitInputData%NElem
  DstInitInputData%NProp = SrcInitInputData%NProp
  DstInitInputData%TDOF = SrcInitInputData%TDOF
  DstInitInputData%MaxMemJnt = SrcInitInputData%MaxMemJnt
IF ( ALLOCATED( SrcInitInputData%Nodes ) ) THEN
  i1 = SIZE(SrcInitInputData%Nodes,1)
  i2 = SIZE(SrcInitInputData%Nodes,2)
  IF (.NOT.ALLOCATED(DstInitInputData%Nodes)) ALLOCATE(DstInitInputData%Nodes(i1,i2))
  DstInitInputData%Nodes = SrcInitInputData%Nodes
ENDIF
IF ( ALLOCATED( SrcInitInputData%Props ) ) THEN
  i1 = SIZE(SrcInitInputData%Props,1)
  i2 = SIZE(SrcInitInputData%Props,2)
  IF (.NOT.ALLOCATED(DstInitInputData%Props)) ALLOCATE(DstInitInputData%Props(i1,i2))
  DstInitInputData%Props = SrcInitInputData%Props
ENDIF
IF ( ALLOCATED( SrcInitInputData%K ) ) THEN
  i1 = SIZE(SrcInitInputData%K,1)
  i2 = SIZE(SrcInitInputData%K,2)
  IF (.NOT.ALLOCATED(DstInitInputData%K)) ALLOCATE(DstInitInputData%K(i1,i2))
  DstInitInputData%K = SrcInitInputData%K
ENDIF
IF ( ALLOCATED( SrcInitInputData%M ) ) THEN
  i1 = SIZE(SrcInitInputData%M,1)
  i2 = SIZE(SrcInitInputData%M,2)
  IF (.NOT.ALLOCATED(DstInitInputData%M)) ALLOCATE(DstInitInputData%M(i1,i2))
  DstInitInputData%M = SrcInitInputData%M
ENDIF
IF ( ALLOCATED( SrcInitInputData%F ) ) THEN
  i1 = SIZE(SrcInitInputData%F,1)
  IF (.NOT.ALLOCATED(DstInitInputData%F)) ALLOCATE(DstInitInputData%F(i1))
  DstInitInputData%F = SrcInitInputData%F
ENDIF
IF ( ALLOCATED( SrcInitInputData%FG ) ) THEN
  i1 = SIZE(SrcInitInputData%FG,1)
  IF (.NOT.ALLOCATED(DstInitInputData%FG)) ALLOCATE(DstInitInputData%FG(i1))
  DstInitInputData%FG = SrcInitInputData%FG
ENDIF
IF ( ALLOCATED( SrcInitInputData%ElemProps ) ) THEN
  i1 = SIZE(SrcInitInputData%ElemProps,1)
  i2 = SIZE(SrcInitInputData%ElemProps,2)
  IF (.NOT.ALLOCATED(DstInitInputData%ElemProps)) ALLOCATE(DstInitInputData%ElemProps(i1,i2))
  DstInitInputData%ElemProps = SrcInitInputData%ElemProps
ENDIF
IF ( ALLOCATED( SrcInitInputData%BCs ) ) THEN
  i1 = SIZE(SrcInitInputData%BCs,1)
  i2 = SIZE(SrcInitInputData%BCs,2)
  IF (.NOT.ALLOCATED(DstInitInputData%BCs)) ALLOCATE(DstInitInputData%BCs(i1,i2))
  DstInitInputData%BCs = SrcInitInputData%BCs
ENDIF
IF ( ALLOCATED( SrcInitInputData%IntFc ) ) THEN
  i1 = SIZE(SrcInitInputData%IntFc,1)
  i2 = SIZE(SrcInitInputData%IntFc,2)
  IF (.NOT.ALLOCATED(DstInitInputData%IntFc)) ALLOCATE(DstInitInputData%IntFc(i1,i2))
  DstInitInputData%IntFc = SrcInitInputData%IntFc
ENDIF
IF ( ALLOCATED( SrcInitInputData%MemberNodes ) ) THEN
  i1 = SIZE(SrcInitInputData%MemberNodes,1)
  i2 = SIZE(SrcInitInputData%MemberNodes,2)
  IF (.NOT.ALLOCATED(DstInitInputData%MemberNodes)) ALLOCATE(DstInitInputData%MemberNodes(i1,i2))
  DstInitInputData%MemberNodes = SrcInitInputData%MemberNodes
ENDIF
IF ( ALLOCATED( SrcInitInputData%NodesConnN ) ) THEN
  i1 = SIZE(SrcInitInputData%NodesConnN,1)
  i2 = SIZE(SrcInitInputData%NodesConnN,2)
  IF (.NOT.ALLOCATED(DstInitInputData%NodesConnN)) ALLOCATE(DstInitInputData%NodesConnN(i1,i2))
  DstInitInputData%NodesConnN = SrcInitInputData%NodesConnN
ENDIF
IF ( ALLOCATED( SrcInitInputData%NodesConnE ) ) THEN
  i1 = SIZE(SrcInitInputData%NodesConnE,1)
  i2 = SIZE(SrcInitInputData%NodesConnE,2)
  IF (.NOT.ALLOCATED(DstInitInputData%NodesConnE)) ALLOCATE(DstInitInputData%NodesConnE(i1,i2))
  DstInitInputData%NodesConnE = SrcInitInputData%NodesConnE
ENDIF
 END SUBROUTINE SD_CopyInitInput

 SUBROUTINE SD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SD_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(InitInputData%Joints) ) DEALLOCATE(InitInputData%Joints)
  IF ( ALLOCATED(InitInputData%PropSets) ) DEALLOCATE(InitInputData%PropSets)
  IF ( ALLOCATED(InitInputData%XPropSets) ) DEALLOCATE(InitInputData%XPropSets)
  IF ( ALLOCATED(InitInputData%COSMs) ) DEALLOCATE(InitInputData%COSMs)
  IF ( ALLOCATED(InitInputData%CMass) ) DEALLOCATE(InitInputData%CMass)
  IF ( ALLOCATED(InitInputData%JDampings) ) DEALLOCATE(InitInputData%JDampings)
  IF ( ALLOCATED(InitInputData%Members) ) DEALLOCATE(InitInputData%Members)
  IF ( ALLOCATED(InitInputData%Interf) ) DEALLOCATE(InitInputData%Interf)
  IF ( ALLOCATED(InitInputData%Nodes) ) DEALLOCATE(InitInputData%Nodes)
  IF ( ALLOCATED(InitInputData%Props) ) DEALLOCATE(InitInputData%Props)
  IF ( ALLOCATED(InitInputData%K) ) DEALLOCATE(InitInputData%K)
  IF ( ALLOCATED(InitInputData%M) ) DEALLOCATE(InitInputData%M)
  IF ( ALLOCATED(InitInputData%F) ) DEALLOCATE(InitInputData%F)
  IF ( ALLOCATED(InitInputData%FG) ) DEALLOCATE(InitInputData%FG)
  IF ( ALLOCATED(InitInputData%ElemProps) ) DEALLOCATE(InitInputData%ElemProps)
  IF ( ALLOCATED(InitInputData%BCs) ) DEALLOCATE(InitInputData%BCs)
  IF ( ALLOCATED(InitInputData%IntFc) ) DEALLOCATE(InitInputData%IntFc)
  IF ( ALLOCATED(InitInputData%MemberNodes) ) DEALLOCATE(InitInputData%MemberNodes)
  IF ( ALLOCATED(InitInputData%NodesConnN) ) DEALLOCATE(InitInputData%NodesConnN)
  IF ( ALLOCATED(InitInputData%NodesConnE) ) DEALLOCATE(InitInputData%NodesConnE)
 END SUBROUTINE SD_DestroyInitInput

 SUBROUTINE SD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz    = Re_BufSz    + SIZE( InData%TP_RefPoint )  ! TP_RefPoint 
  Re_BufSz   = Re_BufSz   + 1  ! DT
  Int_BufSz  = Int_BufSz  + 1  ! ErrStat
  Int_BufSz  = Int_BufSz  + 1  ! NJoints
  Int_BufSz  = Int_BufSz  + 1  ! JointsCol
  Int_BufSz  = Int_BufSz  + 1  ! MembersCol
  Int_BufSz  = Int_BufSz  + 1  ! NPropSets
  Int_BufSz  = Int_BufSz  + 1  ! PropSetsCol
  Int_BufSz  = Int_BufSz  + 1  ! NXPropSets
  Int_BufSz  = Int_BufSz  + 1  ! XPropSetsCol
  Int_BufSz  = Int_BufSz  + 1  ! ReactCol
  Int_BufSz  = Int_BufSz  + 1  ! NInterf
  Int_BufSz  = Int_BufSz  + 1  ! InterfCol
  Int_BufSz  = Int_BufSz  + 1  ! NCMass
  Int_BufSz  = Int_BufSz  + 1  ! CMassCol
  Int_BufSz  = Int_BufSz  + 1  ! NCOSMs
  Int_BufSz  = Int_BufSz  + 1  ! COSMsCol
  Int_BufSz  = Int_BufSz  + 1  ! FEMMod
  Int_BufSz  = Int_BufSz  + 1  ! NDiv
  Re_BufSz    = Re_BufSz    + SIZE( InData%Joints )  ! Joints 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PropSets )  ! PropSets 
  Re_BufSz    = Re_BufSz    + SIZE( InData%XPropSets )  ! XPropSets 
  Re_BufSz    = Re_BufSz    + SIZE( InData%COSMs )  ! COSMs 
  Re_BufSz    = Re_BufSz    + SIZE( InData%CMass )  ! CMass 
  Re_BufSz    = Re_BufSz    + SIZE( InData%JDampings )  ! JDampings 
  Int_BufSz   = Int_BufSz   + SIZE( InData%Members )  ! Members 
  Int_BufSz   = Int_BufSz   + SIZE( InData%Interf )  ! Interf 
  Int_BufSz  = Int_BufSz  + 1  ! NNode
  Int_BufSz  = Int_BufSz  + 1  ! NElem
  Int_BufSz  = Int_BufSz  + 1  ! NProp
  Int_BufSz  = Int_BufSz  + 1  ! TDOF
  Int_BufSz  = Int_BufSz  + 1  ! MaxMemJnt
  Re_BufSz    = Re_BufSz    + SIZE( InData%Nodes )  ! Nodes 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Props )  ! Props 
  Re_BufSz    = Re_BufSz    + SIZE( InData%K )  ! K 
  Re_BufSz    = Re_BufSz    + SIZE( InData%M )  ! M 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FG )  ! FG 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ElemProps )  ! ElemProps 
  Int_BufSz   = Int_BufSz   + SIZE( InData%BCs )  ! BCs 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IntFc )  ! IntFc 
  Int_BufSz   = Int_BufSz   + SIZE( InData%MemberNodes )  ! MemberNodes 
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnN )  ! NodesConnN 
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnE )  ! NodesConnE 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TP_RefPoint))-1 ) =  PACK(InData%TP_RefPoint ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TP_RefPoint)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DT )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ErrStat )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NJoints )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MembersCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%PropSetsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NXPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%XPropSetsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ReactCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NInterf )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InterfCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCMass )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%CMassCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCOSMs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%COSMsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%FEMMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDiv )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Joints) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Joints))-1 ) =  PACK(InData%Joints ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Joints)
  ENDIF
  IF ( ALLOCATED(InData%PropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PropSets))-1 ) =  PACK(InData%PropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PropSets)
  ENDIF
  IF ( ALLOCATED(InData%XPropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%XPropSets))-1 ) =  PACK(InData%XPropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%XPropSets)
  ENDIF
  IF ( ALLOCATED(InData%COSMs) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%COSMs))-1 ) =  PACK(InData%COSMs ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%COSMs)
  ENDIF
  IF ( ALLOCATED(InData%CMass) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CMass))-1 ) =  PACK(InData%CMass ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CMass)
  ENDIF
  IF ( ALLOCATED(InData%JDampings) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%JDampings))-1 ) =  PACK(InData%JDampings ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%JDampings)
  ENDIF
  IF ( ALLOCATED(InData%Members) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Members))-1 ) = PACK(InData%Members ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Members)
  ENDIF
  IF ( ALLOCATED(InData%Interf) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Interf))-1 ) = PACK(InData%Interf ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Interf)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NElem )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NProp )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TDOF )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxMemJnt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Nodes) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Nodes))-1 ) =  PACK(InData%Nodes ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Nodes)
  ENDIF
  IF ( ALLOCATED(InData%Props) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Props))-1 ) =  PACK(InData%Props ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Props)
  ENDIF
  IF ( ALLOCATED(InData%K) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%K))-1 ) =  PACK(InData%K ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%K)
  ENDIF
  IF ( ALLOCATED(InData%M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%M))-1 ) =  PACK(InData%M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%M)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
  IF ( ALLOCATED(InData%FG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FG))-1 ) =  PACK(InData%FG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FG)
  ENDIF
  IF ( ALLOCATED(InData%ElemProps) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ElemProps))-1 ) =  PACK(InData%ElemProps ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ElemProps)
  ENDIF
  IF ( ALLOCATED(InData%BCs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%BCs))-1 ) = PACK(InData%BCs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%BCs)
  ENDIF
  IF ( ALLOCATED(InData%IntFc) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IntFc))-1 ) = PACK(InData%IntFc ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IntFc)
  ENDIF
  IF ( ALLOCATED(InData%MemberNodes) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MemberNodes))-1 ) = PACK(InData%MemberNodes ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnN) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnN))-1 ) = PACK(InData%NodesConnN ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnE) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnE))-1 ) = PACK(InData%NodesConnE ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnE)
  ENDIF
 END SUBROUTINE SD_PackInitInput

 SUBROUTINE SD_UnpackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%TP_RefPoint,1))); mask1 = .TRUE.
  OutData%TP_RefPoint = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TP_RefPoint))-1 ),mask1,OutData%TP_RefPoint)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TP_RefPoint)
  OutData%DT = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ErrStat = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NJoints = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%JointsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MembersCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%PropSetsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NXPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%XPropSetsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ReactCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NInterf = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InterfCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCMass = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%CMassCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCOSMs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%COSMsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%FEMMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NDiv = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Joints) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Joints,1),SIZE(OutData%Joints,2))); mask2 = .TRUE.
    OutData%Joints = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Joints))-1 ),mask2,OutData%Joints)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Joints)
  ENDIF
  IF ( ALLOCATED(OutData%PropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PropSets,1),SIZE(OutData%PropSets,2))); mask2 = .TRUE.
    OutData%PropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PropSets))-1 ),mask2,OutData%PropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PropSets)
  ENDIF
  IF ( ALLOCATED(OutData%XPropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%XPropSets,1),SIZE(OutData%XPropSets,2))); mask2 = .TRUE.
    OutData%XPropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%XPropSets))-1 ),mask2,OutData%XPropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%XPropSets)
  ENDIF
  IF ( ALLOCATED(OutData%COSMs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%COSMs,1),SIZE(OutData%COSMs,2))); mask2 = .TRUE.
    OutData%COSMs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%COSMs))-1 ),mask2,OutData%COSMs)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%COSMs)
  ENDIF
  IF ( ALLOCATED(OutData%CMass) ) THEN
  ALLOCATE(mask2(SIZE(OutData%CMass,1),SIZE(OutData%CMass,2))); mask2 = .TRUE.
    OutData%CMass = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CMass))-1 ),mask2,OutData%CMass)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CMass)
  ENDIF
  IF ( ALLOCATED(OutData%JDampings) ) THEN
  ALLOCATE(mask1(SIZE(OutData%JDampings,1))); mask1 = .TRUE.
    OutData%JDampings = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%JDampings))-1 ),mask1,OutData%JDampings)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%JDampings)
  ENDIF
  IF ( ALLOCATED(OutData%Members) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Members,1),SIZE(OutData%Members,2))); mask2 = .TRUE.
    OutData%Members = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Members))-1 ),mask2,OutData%Members)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Members)
  ENDIF
  IF ( ALLOCATED(OutData%Interf) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Interf,1),SIZE(OutData%Interf,2))); mask2 = .TRUE.
    OutData%Interf = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Interf))-1 ),mask2,OutData%Interf)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Interf)
  ENDIF
  OutData%NNode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NElem = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NProp = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TDOF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MaxMemJnt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Nodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Nodes,1),SIZE(OutData%Nodes,2))); mask2 = .TRUE.
    OutData%Nodes = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Nodes))-1 ),mask2,OutData%Nodes)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Nodes)
  ENDIF
  IF ( ALLOCATED(OutData%Props) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Props,1),SIZE(OutData%Props,2))); mask2 = .TRUE.
    OutData%Props = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Props))-1 ),mask2,OutData%Props)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Props)
  ENDIF
  IF ( ALLOCATED(OutData%K) ) THEN
  ALLOCATE(mask2(SIZE(OutData%K,1),SIZE(OutData%K,2))); mask2 = .TRUE.
    OutData%K = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%K))-1 ),mask2,OutData%K)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%K)
  ENDIF
  IF ( ALLOCATED(OutData%M) ) THEN
  ALLOCATE(mask2(SIZE(OutData%M,1),SIZE(OutData%M,2))); mask2 = .TRUE.
    OutData%M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%M))-1 ),mask2,OutData%M)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%M)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F,1))); mask1 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask1,OutData%F)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  IF ( ALLOCATED(OutData%FG) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FG,1))); mask1 = .TRUE.
    OutData%FG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FG))-1 ),mask1,OutData%FG)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FG)
  ENDIF
  IF ( ALLOCATED(OutData%ElemProps) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElemProps,1),SIZE(OutData%ElemProps,2))); mask2 = .TRUE.
    OutData%ElemProps = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ElemProps))-1 ),mask2,OutData%ElemProps)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ElemProps)
  ENDIF
  IF ( ALLOCATED(OutData%BCs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%BCs,1),SIZE(OutData%BCs,2))); mask2 = .TRUE.
    OutData%BCs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%BCs))-1 ),mask2,OutData%BCs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%BCs)
  ENDIF
  IF ( ALLOCATED(OutData%IntFc) ) THEN
  ALLOCATE(mask2(SIZE(OutData%IntFc,1),SIZE(OutData%IntFc,2))); mask2 = .TRUE.
    OutData%IntFc = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IntFc))-1 ),mask2,OutData%IntFc)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IntFc)
  ENDIF
  IF ( ALLOCATED(OutData%MemberNodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MemberNodes,1),SIZE(OutData%MemberNodes,2))); mask2 = .TRUE.
    OutData%MemberNodes = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%MemberNodes))-1 ),mask2,OutData%MemberNodes)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnN) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnN,1),SIZE(OutData%NodesConnN,2))); mask2 = .TRUE.
    OutData%NodesConnN = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnN))-1 ),mask2,OutData%NodesConnN)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnE) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnE,1),SIZE(OutData%NodesConnE,2))); mask2 = .TRUE.
    OutData%NodesConnE = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnE))-1 ),mask2,OutData%NodesConnE)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnE)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackInitInput

 SUBROUTINE SD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
  TYPE(SD_initoutputtype), INTENT(INOUT) :: DstInitOutputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcInitOutputData%WriteOutputHdr ) ) THEN
  i1 = SIZE(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputHdr)) ALLOCATE(DstInitOutputData%WriteOutputHdr(i1))
  DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF ( ALLOCATED( SrcInitOutputData%WriteOutputUnt ) ) THEN
  i1 = SIZE(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputUnt)) ALLOCATE(DstInitOutputData%WriteOutputUnt(i1))
  DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
  DstInitOutputData%MaxOutChs = SrcInitOutputData%MaxOutChs
  DstInitOutputData%TabDelim = SrcInitOutputData%TabDelim
  DstInitOutputData%OutCOSM = SrcInitOutputData%OutCOSM
  DstInitOutputData%SSSum = SrcInitOutputData%SSSum
IF ( ALLOCATED( SrcInitOutputData%SSOutList ) ) THEN
  i1 = SIZE(SrcInitOutputData%SSOutList,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%SSOutList)) ALLOCATE(DstInitOutputData%SSOutList(i1))
  DstInitOutputData%SSOutList = SrcInitOutputData%SSOutList
ENDIF
 END SUBROUTINE SD_CopyInitOutput

 SUBROUTINE SD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SD_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(InitOutputData%WriteOutputHdr) ) DEALLOCATE(InitOutputData%WriteOutputHdr)
  IF ( ALLOCATED(InitOutputData%WriteOutputUnt) ) DEALLOCATE(InitOutputData%WriteOutputUnt)
  IF ( ALLOCATED(InitOutputData%SSOutList) ) DEALLOCATE(InitOutputData%SSOutList)
 END SUBROUTINE SD_DestroyInitOutput

 SUBROUTINE SD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MaxOutChs
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxOutChs )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackInitOutput

 SUBROUTINE SD_UnpackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MaxOutChs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackInitOutput

 SUBROUTINE SD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: SrcContStateData
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: DstContStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstContStateData%DummyContState = SrcContStateData%DummyContState
IF ( ALLOCATED( SrcContStateData%qm ) ) THEN
  i1 = SIZE(SrcContStateData%qm,1)
  IF (.NOT.ALLOCATED(DstContStateData%qm)) ALLOCATE(DstContStateData%qm(i1))
  DstContStateData%qm = SrcContStateData%qm
ENDIF
IF ( ALLOCATED( SrcContStateData%qmdot ) ) THEN
  i1 = SIZE(SrcContStateData%qmdot,1)
  IF (.NOT.ALLOCATED(DstContStateData%qmdot)) ALLOCATE(DstContStateData%qmdot(i1))
  DstContStateData%qmdot = SrcContStateData%qmdot
ENDIF
IF ( ALLOCATED( SrcContStateData%qmdotdot ) ) THEN
  i1 = SIZE(SrcContStateData%qmdotdot,1)
  IF (.NOT.ALLOCATED(DstContStateData%qmdotdot)) ALLOCATE(DstContStateData%qmdotdot(i1))
  DstContStateData%qmdotdot = SrcContStateData%qmdotdot
ENDIF
 END SUBROUTINE SD_CopyContState

 SUBROUTINE SD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(ContStateData%qm) ) DEALLOCATE(ContStateData%qm)
  IF ( ALLOCATED(ContStateData%qmdot) ) DEALLOCATE(ContStateData%qmdot)
  IF ( ALLOCATED(ContStateData%qmdotdot) ) DEALLOCATE(ContStateData%qmdotdot)
 END SUBROUTINE SD_DestroyContState

 SUBROUTINE SD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  Re_BufSz    = Re_BufSz    + SIZE( InData%qm )  ! qm 
  Re_BufSz    = Re_BufSz    + SIZE( InData%qmdot )  ! qmdot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%qmdotdot )  ! qmdotdot 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%qm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qm))-1 ) =  PACK(InData%qm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qm)
  ENDIF
  IF ( ALLOCATED(InData%qmdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdot))-1 ) =  PACK(InData%qmdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdot)
  ENDIF
  IF ( ALLOCATED(InData%qmdotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdotdot))-1 ) =  PACK(InData%qmdotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdotdot)
  ENDIF
 END SUBROUTINE SD_PackContState

 SUBROUTINE SD_UnpackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%qm) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qm,1))); mask1 = .TRUE.
    OutData%qm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qm))-1 ),mask1,OutData%qm)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qm)
  ENDIF
  IF ( ALLOCATED(OutData%qmdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdot,1))); mask1 = .TRUE.
    OutData%qmdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdot))-1 ),mask1,OutData%qmdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdot)
  ENDIF
  IF ( ALLOCATED(OutData%qmdotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdotdot,1))); mask1 = .TRUE.
    OutData%qmdotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdotdot))-1 ),mask1,OutData%qmdotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdotdot)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackContState

 SUBROUTINE SD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
  TYPE(SD_discretestatetype), INTENT(INOUT) :: DstDiscStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE SD_CopyDiscState

 SUBROUTINE SD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SD_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyDiscState

 SUBROUTINE SD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackDiscState

 SUBROUTINE SD_UnpackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackDiscState

 SUBROUTINE SD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE SD_CopyConstrState

 SUBROUTINE SD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyConstrState

 SUBROUTINE SD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackConstrState

 SUBROUTINE SD_UnpackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackConstrState

 SUBROUTINE SD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
  TYPE(SD_otherstatetype), INTENT(INOUT) :: DstOtherStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
DO i1 = 1, SIZE(SrcOtherStateData%xdot,1)
  CALL SD_CopyContState( SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat, ErrMsg )
ENDDO
  DstOtherStateData%n = SrcOtherStateData%n
IF ( ALLOCATED( SrcOtherStateData%Udotdot ) ) THEN
  i1 = SIZE(SrcOtherStateData%Udotdot,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%Udotdot)) ALLOCATE(DstOtherStateData%Udotdot(i1))
  DstOtherStateData%Udotdot = SrcOtherStateData%Udotdot
ENDIF
IF ( ALLOCATED( SrcOtherStateData%Y2 ) ) THEN
  i1 = SIZE(SrcOtherStateData%Y2,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%Y2)) ALLOCATE(DstOtherStateData%Y2(i1))
  DstOtherStateData%Y2 = SrcOtherStateData%Y2
ENDIF
 END SUBROUTINE SD_CopyOtherState

 SUBROUTINE SD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SD_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%xdot)) THEN
DO i1 = 1, SIZE(OtherStateData%xdot,1)
  CALL SD_DestroyContState( OtherStateData%xdot(i1), ErrStat, ErrMsg )
ENDDO
ENDIF
  IF ( ALLOCATED(OtherStateData%Udotdot) ) DEALLOCATE(OtherStateData%Udotdot)
  IF ( ALLOCATED(OtherStateData%Y2) ) DEALLOCATE(OtherStateData%Y2)
 END SUBROUTINE SD_DestroyOtherState

 SUBROUTINE SD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_xdot_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = 1, SIZE(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Db_xdot_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Int_xdot_Buf))Int_BufSz = Int_BufSz + SIZE( Int_xdot_Buf ) ! xdot
  IF(ALLOCATED(Re_xdot_Buf))  DEALLOCATE(Re_xdot_Buf)
  IF(ALLOCATED(Db_xdot_Buf))  DEALLOCATE(Db_xdot_Buf)
  IF(ALLOCATED(Int_xdot_Buf)) DEALLOCATE(Int_xdot_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! n
  Re_BufSz    = Re_BufSz    + SIZE( InData%Udotdot )  ! Udotdot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Y2 )  ! Y2 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
DO i1 = 1, SIZE(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, OnlySize ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 ) = Re_xdot_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 ) = Db_xdot_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 ) = Int_xdot_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  IF( ALLOCATED(Re_xdot_Buf) )  DEALLOCATE(Re_xdot_Buf)
  IF( ALLOCATED(Db_xdot_Buf) )  DEALLOCATE(Db_xdot_Buf)
  IF( ALLOCATED(Int_xdot_Buf) ) DEALLOCATE(Int_xdot_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%n )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Udotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Udotdot))-1 ) =  PACK(InData%Udotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Udotdot)
  ENDIF
  IF ( ALLOCATED(InData%Y2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Y2))-1 ) =  PACK(InData%Y2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Y2)
  ENDIF
 END SUBROUTINE SD_PackOtherState

 SUBROUTINE SD_UnpackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_xdot_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = 1, SIZE(OutData%xdot,1)
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    Re_xdot_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    Db_xdot_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    Int_xdot_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  CALL SD_UnpackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg ) ! xdot 
ENDDO
  OutData%n = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Udotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Udotdot,1))); mask1 = .TRUE.
    OutData%Udotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Udotdot))-1 ),mask1,OutData%Udotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Udotdot)
  ENDIF
  IF ( ALLOCATED(OutData%Y2) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Y2,1))); mask1 = .TRUE.
    OutData%Y2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Y2))-1 ),mask1,OutData%Y2)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Y2)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackOtherState

 SUBROUTINE SD_Copyoutvar_type( Srcoutvar_typeData, Dstoutvar_typeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_outvar_type), INTENT(INOUT) :: Srcoutvar_typeData
  TYPE(sd_outvar_type), INTENT(INOUT) :: Dstoutvar_typeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  Dstoutvar_typeData%Indx = Srcoutvar_typeData%Indx
  Dstoutvar_typeData%SignM = Srcoutvar_typeData%SignM
  Dstoutvar_typeData%Units = Srcoutvar_typeData%Units
  Dstoutvar_typeData%Name = Srcoutvar_typeData%Name
 END SUBROUTINE SD_Copyoutvar_type

 SUBROUTINE SD_Destroyoutvar_type( outvar_typeData, ErrStat, ErrMsg )
  TYPE(sd_outvar_type), INTENT(INOUT) :: outvar_typeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_Destroyoutvar_type

 SUBROUTINE SD_Packoutvar_type( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_outvar_type),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! Indx
  Int_BufSz  = Int_BufSz  + 1  ! SignM
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%SignM )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_Packoutvar_type

 SUBROUTINE SD_Unpackoutvar_type( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_outvar_type), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%SignM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackoutvar_type

 SUBROUTINE SD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_parametertype), INTENT(INOUT) :: SrcParamData
  TYPE(SD_parametertype), INTENT(INOUT) :: DstParamData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcParamData%A_21 ) ) THEN
  i1 = SIZE(SrcParamData%A_21,1)
  i2 = SIZE(SrcParamData%A_21,2)
  IF (.NOT.ALLOCATED(DstParamData%A_21)) ALLOCATE(DstParamData%A_21(i1,i2))
  DstParamData%A_21 = SrcParamData%A_21
ENDIF
IF ( ALLOCATED( SrcParamData%A_22 ) ) THEN
  i1 = SIZE(SrcParamData%A_22,1)
  i2 = SIZE(SrcParamData%A_22,2)
  IF (.NOT.ALLOCATED(DstParamData%A_22)) ALLOCATE(DstParamData%A_22(i1,i2))
  DstParamData%A_22 = SrcParamData%A_22
ENDIF
IF ( ALLOCATED( SrcParamData%B_23 ) ) THEN
  i1 = SIZE(SrcParamData%B_23,1)
  i2 = SIZE(SrcParamData%B_23,2)
  IF (.NOT.ALLOCATED(DstParamData%B_23)) ALLOCATE(DstParamData%B_23(i1,i2))
  DstParamData%B_23 = SrcParamData%B_23
ENDIF
IF ( ALLOCATED( SrcParamData%B_24 ) ) THEN
  i1 = SIZE(SrcParamData%B_24,1)
  i2 = SIZE(SrcParamData%B_24,2)
  IF (.NOT.ALLOCATED(DstParamData%B_24)) ALLOCATE(DstParamData%B_24(i1,i2))
  DstParamData%B_24 = SrcParamData%B_24
ENDIF
IF ( ALLOCATED( SrcParamData%FX ) ) THEN
  i1 = SIZE(SrcParamData%FX,1)
  IF (.NOT.ALLOCATED(DstParamData%FX)) ALLOCATE(DstParamData%FX(i1))
  DstParamData%FX = SrcParamData%FX
ENDIF
IF ( ALLOCATED( SrcParamData%C1_11 ) ) THEN
  i1 = SIZE(SrcParamData%C1_11,1)
  i2 = SIZE(SrcParamData%C1_11,2)
  IF (.NOT.ALLOCATED(DstParamData%C1_11)) ALLOCATE(DstParamData%C1_11(i1,i2))
  DstParamData%C1_11 = SrcParamData%C1_11
ENDIF
IF ( ALLOCATED( SrcParamData%C1_12 ) ) THEN
  i1 = SIZE(SrcParamData%C1_12,1)
  i2 = SIZE(SrcParamData%C1_12,2)
  IF (.NOT.ALLOCATED(DstParamData%C1_12)) ALLOCATE(DstParamData%C1_12(i1,i2))
  DstParamData%C1_12 = SrcParamData%C1_12
ENDIF
IF ( ALLOCATED( SrcParamData%D1_11 ) ) THEN
  i1 = SIZE(SrcParamData%D1_11,1)
  i2 = SIZE(SrcParamData%D1_11,2)
  IF (.NOT.ALLOCATED(DstParamData%D1_11)) ALLOCATE(DstParamData%D1_11(i1,i2))
  DstParamData%D1_11 = SrcParamData%D1_11
ENDIF
IF ( ALLOCATED( SrcParamData%D1_13 ) ) THEN
  i1 = SIZE(SrcParamData%D1_13,1)
  i2 = SIZE(SrcParamData%D1_13,2)
  IF (.NOT.ALLOCATED(DstParamData%D1_13)) ALLOCATE(DstParamData%D1_13(i1,i2))
  DstParamData%D1_13 = SrcParamData%D1_13
ENDIF
IF ( ALLOCATED( SrcParamData%D1_14 ) ) THEN
  i1 = SIZE(SrcParamData%D1_14,1)
  i2 = SIZE(SrcParamData%D1_14,2)
  IF (.NOT.ALLOCATED(DstParamData%D1_14)) ALLOCATE(DstParamData%D1_14(i1,i2))
  DstParamData%D1_14 = SrcParamData%D1_14
ENDIF
IF ( ALLOCATED( SrcParamData%FY ) ) THEN
  i1 = SIZE(SrcParamData%FY,1)
  IF (.NOT.ALLOCATED(DstParamData%FY)) ALLOCATE(DstParamData%FY(i1))
  DstParamData%FY = SrcParamData%FY
ENDIF
IF ( ALLOCATED( SrcParamData%C2_21 ) ) THEN
  i1 = SIZE(SrcParamData%C2_21,1)
  i2 = SIZE(SrcParamData%C2_21,2)
  IF (.NOT.ALLOCATED(DstParamData%C2_21)) ALLOCATE(DstParamData%C2_21(i1,i2))
  DstParamData%C2_21 = SrcParamData%C2_21
ENDIF
IF ( ALLOCATED( SrcParamData%C2_42 ) ) THEN
  i1 = SIZE(SrcParamData%C2_42,1)
  i2 = SIZE(SrcParamData%C2_42,2)
  IF (.NOT.ALLOCATED(DstParamData%C2_42)) ALLOCATE(DstParamData%C2_42(i1,i2))
  DstParamData%C2_42 = SrcParamData%C2_42
ENDIF
IF ( ALLOCATED( SrcParamData%D2_11 ) ) THEN
  i1 = SIZE(SrcParamData%D2_11,1)
  i2 = SIZE(SrcParamData%D2_11,2)
  IF (.NOT.ALLOCATED(DstParamData%D2_11)) ALLOCATE(DstParamData%D2_11(i1,i2))
  DstParamData%D2_11 = SrcParamData%D2_11
ENDIF
IF ( ALLOCATED( SrcParamData%D2_21 ) ) THEN
  i1 = SIZE(SrcParamData%D2_21,1)
  i2 = SIZE(SrcParamData%D2_21,2)
  IF (.NOT.ALLOCATED(DstParamData%D2_21)) ALLOCATE(DstParamData%D2_21(i1,i2))
  DstParamData%D2_21 = SrcParamData%D2_21
ENDIF
IF ( ALLOCATED( SrcParamData%D2_32 ) ) THEN
  i1 = SIZE(SrcParamData%D2_32,1)
  i2 = SIZE(SrcParamData%D2_32,2)
  IF (.NOT.ALLOCATED(DstParamData%D2_32)) ALLOCATE(DstParamData%D2_32(i1,i2))
  DstParamData%D2_32 = SrcParamData%D2_32
ENDIF
IF ( ALLOCATED( SrcParamData%D2_42 ) ) THEN
  i1 = SIZE(SrcParamData%D2_42,1)
  i2 = SIZE(SrcParamData%D2_42,2)
  IF (.NOT.ALLOCATED(DstParamData%D2_42)) ALLOCATE(DstParamData%D2_42(i1,i2))
  DstParamData%D2_42 = SrcParamData%D2_42
ENDIF
IF ( ALLOCATED( SrcParamData%Abar_21 ) ) THEN
  i1 = SIZE(SrcParamData%Abar_21,1)
  i2 = SIZE(SrcParamData%Abar_21,2)
  IF (.NOT.ALLOCATED(DstParamData%Abar_21)) ALLOCATE(DstParamData%Abar_21(i1,i2))
  DstParamData%Abar_21 = SrcParamData%Abar_21
ENDIF
IF ( ALLOCATED( SrcParamData%Abar_22 ) ) THEN
  i1 = SIZE(SrcParamData%Abar_22,1)
  i2 = SIZE(SrcParamData%Abar_22,2)
  IF (.NOT.ALLOCATED(DstParamData%Abar_22)) ALLOCATE(DstParamData%Abar_22(i1,i2))
  DstParamData%Abar_22 = SrcParamData%Abar_22
ENDIF
IF ( ALLOCATED( SrcParamData%Bbar_13 ) ) THEN
  i1 = SIZE(SrcParamData%Bbar_13,1)
  i2 = SIZE(SrcParamData%Bbar_13,2)
  IF (.NOT.ALLOCATED(DstParamData%Bbar_13)) ALLOCATE(DstParamData%Bbar_13(i1,i2))
  DstParamData%Bbar_13 = SrcParamData%Bbar_13
ENDIF
IF ( ALLOCATED( SrcParamData%Bbar_23 ) ) THEN
  i1 = SIZE(SrcParamData%Bbar_23,1)
  i2 = SIZE(SrcParamData%Bbar_23,2)
  IF (.NOT.ALLOCATED(DstParamData%Bbar_23)) ALLOCATE(DstParamData%Bbar_23(i1,i2))
  DstParamData%Bbar_23 = SrcParamData%Bbar_23
ENDIF
IF ( ALLOCATED( SrcParamData%Bbar_24 ) ) THEN
  i1 = SIZE(SrcParamData%Bbar_24,1)
  i2 = SIZE(SrcParamData%Bbar_24,2)
  IF (.NOT.ALLOCATED(DstParamData%Bbar_24)) ALLOCATE(DstParamData%Bbar_24(i1,i2))
  DstParamData%Bbar_24 = SrcParamData%Bbar_24
ENDIF
IF ( ALLOCATED( SrcParamData%Fbar_21 ) ) THEN
  i1 = SIZE(SrcParamData%Fbar_21,1)
  IF (.NOT.ALLOCATED(DstParamData%Fbar_21)) ALLOCATE(DstParamData%Fbar_21(i1))
  DstParamData%Fbar_21 = SrcParamData%Fbar_21
ENDIF
IF ( ALLOCATED( SrcParamData%MBB ) ) THEN
  i1 = SIZE(SrcParamData%MBB,1)
  i2 = SIZE(SrcParamData%MBB,2)
  IF (.NOT.ALLOCATED(DstParamData%MBB)) ALLOCATE(DstParamData%MBB(i1,i2))
  DstParamData%MBB = SrcParamData%MBB
ENDIF
IF ( ALLOCATED( SrcParamData%KBB ) ) THEN
  i1 = SIZE(SrcParamData%KBB,1)
  i2 = SIZE(SrcParamData%KBB,2)
  IF (.NOT.ALLOCATED(DstParamData%KBB)) ALLOCATE(DstParamData%KBB(i1,i2))
  DstParamData%KBB = SrcParamData%KBB
ENDIF
IF ( ALLOCATED( SrcParamData%MBM ) ) THEN
  i1 = SIZE(SrcParamData%MBM,1)
  i2 = SIZE(SrcParamData%MBM,2)
  IF (.NOT.ALLOCATED(DstParamData%MBM)) ALLOCATE(DstParamData%MBM(i1,i2))
  DstParamData%MBM = SrcParamData%MBM
ENDIF
IF ( ALLOCATED( SrcParamData%PHI_R ) ) THEN
  i1 = SIZE(SrcParamData%PHI_R,1)
  i2 = SIZE(SrcParamData%PHI_R,2)
  IF (.NOT.ALLOCATED(DstParamData%PHI_R)) ALLOCATE(DstParamData%PHI_R(i1,i2))
  DstParamData%PHI_R = SrcParamData%PHI_R
ENDIF
IF ( ALLOCATED( SrcParamData%PHI_M ) ) THEN
  i1 = SIZE(SrcParamData%PHI_M,1)
  i2 = SIZE(SrcParamData%PHI_M,2)
  IF (.NOT.ALLOCATED(DstParamData%PHI_M)) ALLOCATE(DstParamData%PHI_M(i1,i2))
  DstParamData%PHI_M = SrcParamData%PHI_M
ENDIF
IF ( ALLOCATED( SrcParamData%TIreact ) ) THEN
  i1 = SIZE(SrcParamData%TIreact,1)
  i2 = SIZE(SrcParamData%TIreact,2)
  IF (.NOT.ALLOCATED(DstParamData%TIreact)) ALLOCATE(DstParamData%TIreact(i1,i2))
  DstParamData%TIreact = SrcParamData%TIreact
ENDIF
  DstParamData%NModes = SrcParamData%NModes
IF ( ALLOCATED( SrcParamData%Elems ) ) THEN
  i1 = SIZE(SrcParamData%Elems,1)
  i2 = SIZE(SrcParamData%Elems,2)
  IF (.NOT.ALLOCATED(DstParamData%Elems)) ALLOCATE(DstParamData%Elems(i1,i2))
  DstParamData%Elems = SrcParamData%Elems
ENDIF
  DstParamData%qmL = SrcParamData%qmL
  DstParamData%uL = SrcParamData%uL
  DstParamData%DofL = SrcParamData%DofL
  DstParamData%NNodes_L = SrcParamData%NNodes_L
  DstParamData%DofI = SrcParamData%DofI
  DstParamData%DofR = SrcParamData%DofR
  DstParamData%DofC = SrcParamData%DofC
  DstParamData%NReact = SrcParamData%NReact
IF ( ALLOCATED( SrcParamData%Reacts ) ) THEN
  i1 = SIZE(SrcParamData%Reacts,1)
  i2 = SIZE(SrcParamData%Reacts,2)
  IF (.NOT.ALLOCATED(DstParamData%Reacts)) ALLOCATE(DstParamData%Reacts(i1,i2))
  DstParamData%Reacts = SrcParamData%Reacts
ENDIF
  DstParamData%Nmembers = SrcParamData%Nmembers
  DstParamData%TPdofL = SrcParamData%TPdofL
  DstParamData%URbarL = SrcParamData%URbarL
  DstParamData%URdotdotL = SrcParamData%URdotdotL
  DstParamData%UdotdotL = SrcParamData%UdotdotL
  DstParamData%Y2L = SrcParamData%Y2L
  DstParamData%IntMethod = SrcParamData%IntMethod
  DstParamData%NAvgEls = SrcParamData%NAvgEls
IF ( ALLOCATED( SrcParamData%IDI ) ) THEN
  i1 = SIZE(SrcParamData%IDI,1)
  IF (.NOT.ALLOCATED(DstParamData%IDI)) ALLOCATE(DstParamData%IDI(i1))
  DstParamData%IDI = SrcParamData%IDI
ENDIF
IF ( ALLOCATED( SrcParamData%IDR ) ) THEN
  i1 = SIZE(SrcParamData%IDR,1)
  IF (.NOT.ALLOCATED(DstParamData%IDR)) ALLOCATE(DstParamData%IDR(i1))
  DstParamData%IDR = SrcParamData%IDR
ENDIF
IF ( ALLOCATED( SrcParamData%IDL ) ) THEN
  i1 = SIZE(SrcParamData%IDL,1)
  IF (.NOT.ALLOCATED(DstParamData%IDL)) ALLOCATE(DstParamData%IDL(i1))
  DstParamData%IDL = SrcParamData%IDL
ENDIF
IF ( ALLOCATED( SrcParamData%IDC ) ) THEN
  i1 = SIZE(SrcParamData%IDC,1)
  IF (.NOT.ALLOCATED(DstParamData%IDC)) ALLOCATE(DstParamData%IDC(i1))
  DstParamData%IDC = SrcParamData%IDC
ENDIF
IF ( ALLOCATED( SrcParamData%IDY ) ) THEN
  i1 = SIZE(SrcParamData%IDY,1)
  IF (.NOT.ALLOCATED(DstParamData%IDY)) ALLOCATE(DstParamData%IDY(i1))
  DstParamData%IDY = SrcParamData%IDY
ENDIF
  DstParamData%NMOutputs = SrcParamData%NMOutputs
  DstParamData%NumOuts = SrcParamData%NumOuts
  DstParamData%SDDeltaT = SrcParamData%SDDeltaT
  DstParamData%OutSwtch = SrcParamData%OutSwtch
  DstParamData%UnJckF = SrcParamData%UnJckF
  DstParamData%Delim = SrcParamData%Delim
  DstParamData%OutFmt = SrcParamData%OutFmt
  DstParamData%OutSFmt = SrcParamData%OutSFmt
  DstParamData%OutJckF = SrcParamData%OutJckF
  DstParamData%JEchoFile = SrcParamData%JEchoFile
DO i1 = 1, SIZE(SrcParamData%MoutLst,1)
  CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst(i1), DstParamData%MoutLst(i1), CtrlCode, ErrStat, ErrMsg )
ENDDO
DO i1 = 1, SIZE(SrcParamData%MoutLst2,1)
  CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst2(i1), DstParamData%MoutLst2(i1), CtrlCode, ErrStat, ErrMsg )
ENDDO
DO i1 = 1, SIZE(SrcParamData%MoutLst3,1)
  CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst3(i1), DstParamData%MoutLst3(i1), CtrlCode, ErrStat, ErrMsg )
ENDDO
DO i1 = 1, SIZE(SrcParamData%ElemProps,1)
  CALL SD_Copyelemproptype( SrcParamData%ElemProps(i1), DstParamData%ElemProps(i1), CtrlCode, ErrStat, ErrMsg )
ENDDO
DO i1 = 1, SIZE(SrcParamData%OutParam,1)
  CALL SD_Copyoutvar_type( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat, ErrMsg )
ENDDO
  DstParamData%OutAll = SrcParamData%OutAll
  DstParamData%OutReact = SrcParamData%OutReact
  DstParamData%OutAllInt = SrcParamData%OutAllInt
  DstParamData%OutAllDims = SrcParamData%OutAllDims
  DstParamData%OutDec = SrcParamData%OutDec
  DstParamData%MaxOUtPts = SrcParamData%MaxOUtPts
 END SUBROUTINE SD_CopyParam

 SUBROUTINE SD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SD_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(ParamData%A_21) ) DEALLOCATE(ParamData%A_21)
  IF ( ALLOCATED(ParamData%A_22) ) DEALLOCATE(ParamData%A_22)
  IF ( ALLOCATED(ParamData%B_23) ) DEALLOCATE(ParamData%B_23)
  IF ( ALLOCATED(ParamData%B_24) ) DEALLOCATE(ParamData%B_24)
  IF ( ALLOCATED(ParamData%FX) ) DEALLOCATE(ParamData%FX)
  IF ( ALLOCATED(ParamData%C1_11) ) DEALLOCATE(ParamData%C1_11)
  IF ( ALLOCATED(ParamData%C1_12) ) DEALLOCATE(ParamData%C1_12)
  IF ( ALLOCATED(ParamData%D1_11) ) DEALLOCATE(ParamData%D1_11)
  IF ( ALLOCATED(ParamData%D1_13) ) DEALLOCATE(ParamData%D1_13)
  IF ( ALLOCATED(ParamData%D1_14) ) DEALLOCATE(ParamData%D1_14)
  IF ( ALLOCATED(ParamData%FY) ) DEALLOCATE(ParamData%FY)
  IF ( ALLOCATED(ParamData%C2_21) ) DEALLOCATE(ParamData%C2_21)
  IF ( ALLOCATED(ParamData%C2_42) ) DEALLOCATE(ParamData%C2_42)
  IF ( ALLOCATED(ParamData%D2_11) ) DEALLOCATE(ParamData%D2_11)
  IF ( ALLOCATED(ParamData%D2_21) ) DEALLOCATE(ParamData%D2_21)
  IF ( ALLOCATED(ParamData%D2_32) ) DEALLOCATE(ParamData%D2_32)
  IF ( ALLOCATED(ParamData%D2_42) ) DEALLOCATE(ParamData%D2_42)
  IF ( ALLOCATED(ParamData%Abar_21) ) DEALLOCATE(ParamData%Abar_21)
  IF ( ALLOCATED(ParamData%Abar_22) ) DEALLOCATE(ParamData%Abar_22)
  IF ( ALLOCATED(ParamData%Bbar_13) ) DEALLOCATE(ParamData%Bbar_13)
  IF ( ALLOCATED(ParamData%Bbar_23) ) DEALLOCATE(ParamData%Bbar_23)
  IF ( ALLOCATED(ParamData%Bbar_24) ) DEALLOCATE(ParamData%Bbar_24)
  IF ( ALLOCATED(ParamData%Fbar_21) ) DEALLOCATE(ParamData%Fbar_21)
  IF ( ALLOCATED(ParamData%MBB) ) DEALLOCATE(ParamData%MBB)
  IF ( ALLOCATED(ParamData%KBB) ) DEALLOCATE(ParamData%KBB)
  IF ( ALLOCATED(ParamData%MBM) ) DEALLOCATE(ParamData%MBM)
  IF ( ALLOCATED(ParamData%PHI_R) ) DEALLOCATE(ParamData%PHI_R)
  IF ( ALLOCATED(ParamData%PHI_M) ) DEALLOCATE(ParamData%PHI_M)
  IF ( ALLOCATED(ParamData%TIreact) ) DEALLOCATE(ParamData%TIreact)
  IF ( ALLOCATED(ParamData%Elems) ) DEALLOCATE(ParamData%Elems)
  IF ( ALLOCATED(ParamData%Reacts) ) DEALLOCATE(ParamData%Reacts)
  IF ( ALLOCATED(ParamData%IDI) ) DEALLOCATE(ParamData%IDI)
  IF ( ALLOCATED(ParamData%IDR) ) DEALLOCATE(ParamData%IDR)
  IF ( ALLOCATED(ParamData%IDL) ) DEALLOCATE(ParamData%IDL)
  IF ( ALLOCATED(ParamData%IDC) ) DEALLOCATE(ParamData%IDC)
  IF ( ALLOCATED(ParamData%IDY) ) DEALLOCATE(ParamData%IDY)
IF (ALLOCATED(ParamData%MoutLst)) THEN
DO i1 = 1, SIZE(ParamData%MoutLst,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst(i1), ErrStat, ErrMsg )
ENDDO
ENDIF
IF (ALLOCATED(ParamData%MoutLst2)) THEN
DO i1 = 1, SIZE(ParamData%MoutLst2,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst2(i1), ErrStat, ErrMsg )
ENDDO
ENDIF
IF (ALLOCATED(ParamData%MoutLst3)) THEN
DO i1 = 1, SIZE(ParamData%MoutLst3,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst3(i1), ErrStat, ErrMsg )
ENDDO
ENDIF
IF (ALLOCATED(ParamData%ElemProps)) THEN
DO i1 = 1, SIZE(ParamData%ElemProps,1)
  CALL SD_Destroyelemproptype( ParamData%ElemProps(i1), ErrStat, ErrMsg )
ENDDO
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = 1, SIZE(ParamData%OutParam,1)
  CALL SD_Destroyoutvar_type( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
ENDIF
 END SUBROUTINE SD_DestroyParam

 SUBROUTINE SD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%A_21 )  ! A_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%A_22 )  ! A_22 
  Re_BufSz    = Re_BufSz    + SIZE( InData%B_23 )  ! B_23 
  Re_BufSz    = Re_BufSz    + SIZE( InData%B_24 )  ! B_24 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FX )  ! FX 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C1_11 )  ! C1_11 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C1_12 )  ! C1_12 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D1_11 )  ! D1_11 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D1_13 )  ! D1_13 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D1_14 )  ! D1_14 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FY )  ! FY 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C2_21 )  ! C2_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C2_42 )  ! C2_42 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_11 )  ! D2_11 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_21 )  ! D2_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_32 )  ! D2_32 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_42 )  ! D2_42 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Abar_21 )  ! Abar_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Abar_22 )  ! Abar_22 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Bbar_13 )  ! Bbar_13 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Bbar_23 )  ! Bbar_23 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Bbar_24 )  ! Bbar_24 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fbar_21 )  ! Fbar_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%MBB )  ! MBB 
  Re_BufSz    = Re_BufSz    + SIZE( InData%KBB )  ! KBB 
  Re_BufSz    = Re_BufSz    + SIZE( InData%MBM )  ! MBM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PHI_R )  ! PHI_R 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PHI_M )  ! PHI_M 
  Re_BufSz    = Re_BufSz    + SIZE( InData%TIreact )  ! TIreact 
  Int_BufSz  = Int_BufSz  + 1  ! NModes
  Int_BufSz   = Int_BufSz   + SIZE( InData%Elems )  ! Elems 
  Int_BufSz  = Int_BufSz  + 1  ! qmL
  Int_BufSz  = Int_BufSz  + 1  ! uL
  Int_BufSz  = Int_BufSz  + 1  ! DofL
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_L
  Int_BufSz  = Int_BufSz  + 1  ! DofI
  Int_BufSz  = Int_BufSz  + 1  ! DofR
  Int_BufSz  = Int_BufSz  + 1  ! DofC
  Int_BufSz  = Int_BufSz  + 1  ! NReact
  Int_BufSz   = Int_BufSz   + SIZE( InData%Reacts )  ! Reacts 
  Int_BufSz  = Int_BufSz  + 1  ! Nmembers
  Int_BufSz  = Int_BufSz  + 1  ! TPdofL
  Int_BufSz  = Int_BufSz  + 1  ! URbarL
  Int_BufSz  = Int_BufSz  + 1  ! URdotdotL
  Int_BufSz  = Int_BufSz  + 1  ! UdotdotL
  Int_BufSz  = Int_BufSz  + 1  ! Y2L
  Int_BufSz  = Int_BufSz  + 1  ! IntMethod
  Int_BufSz  = Int_BufSz  + 1  ! NAvgEls
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDI )  ! IDI 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDR )  ! IDR 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDL )  ! IDL 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDC )  ! IDC 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDY )  ! IDY 
  Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Re_BufSz   = Re_BufSz   + 1  ! SDDeltaT
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
  Int_BufSz  = Int_BufSz  + 1  ! UnJckF
DO i1 = 1, SIZE(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Db_MoutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Int_MoutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst_Buf ) ! MoutLst
  IF(ALLOCATED(Re_MoutLst_Buf))  DEALLOCATE(Re_MoutLst_Buf)
  IF(ALLOCATED(Db_MoutLst_Buf))  DEALLOCATE(Db_MoutLst_Buf)
  IF(ALLOCATED(Int_MoutLst_Buf)) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = 1, SIZE(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Db_MoutLst2_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Int_MoutLst2_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst2_Buf ) ! MoutLst2
  IF(ALLOCATED(Re_MoutLst2_Buf))  DEALLOCATE(Re_MoutLst2_Buf)
  IF(ALLOCATED(Db_MoutLst2_Buf))  DEALLOCATE(Db_MoutLst2_Buf)
  IF(ALLOCATED(Int_MoutLst2_Buf)) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = 1, SIZE(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Db_MoutLst3_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Int_MoutLst3_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst3_Buf ) ! MoutLst3
  IF(ALLOCATED(Re_MoutLst3_Buf))  DEALLOCATE(Re_MoutLst3_Buf)
  IF(ALLOCATED(Db_MoutLst3_Buf))  DEALLOCATE(Db_MoutLst3_Buf)
  IF(ALLOCATED(Int_MoutLst3_Buf)) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = 1, SIZE(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Db_ElemProps_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Int_ElemProps_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ElemProps_Buf ) ! ElemProps
  IF(ALLOCATED(Re_ElemProps_Buf))  DEALLOCATE(Re_ElemProps_Buf)
  IF(ALLOCATED(Db_ElemProps_Buf))  DEALLOCATE(Db_ElemProps_Buf)
  IF(ALLOCATED(Int_ElemProps_Buf)) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = 1, SIZE(InData%OutParam,1)
  CALL SD_Packoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! OutAllInt
  Int_BufSz  = Int_BufSz  + 1  ! OutAllDims
  Int_BufSz  = Int_BufSz  + 1  ! OutDec
  Int_BufSz  = Int_BufSz  + 1  ! MaxOUtPts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%A_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%A_21))-1 ) =  PACK(InData%A_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%A_21)
  ENDIF
  IF ( ALLOCATED(InData%A_22) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%A_22))-1 ) =  PACK(InData%A_22 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%A_22)
  ENDIF
  IF ( ALLOCATED(InData%B_23) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%B_23))-1 ) =  PACK(InData%B_23 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%B_23)
  ENDIF
  IF ( ALLOCATED(InData%B_24) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%B_24))-1 ) =  PACK(InData%B_24 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%B_24)
  ENDIF
  IF ( ALLOCATED(InData%FX) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FX)
  ENDIF
  IF ( ALLOCATED(InData%C1_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_11))-1 ) =  PACK(InData%C1_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_11)
  ENDIF
  IF ( ALLOCATED(InData%C1_12) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_12))-1 ) =  PACK(InData%C1_12 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_12)
  ENDIF
  IF ( ALLOCATED(InData%D1_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_11))-1 ) =  PACK(InData%D1_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_11)
  ENDIF
  IF ( ALLOCATED(InData%D1_13) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_13))-1 ) =  PACK(InData%D1_13 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_13)
  ENDIF
  IF ( ALLOCATED(InData%D1_14) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_14))-1 ) =  PACK(InData%D1_14 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_14)
  ENDIF
  IF ( ALLOCATED(InData%FY) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FY)
  ENDIF
  IF ( ALLOCATED(InData%C2_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_21))-1 ) =  PACK(InData%C2_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_21)
  ENDIF
  IF ( ALLOCATED(InData%C2_42) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_42))-1 ) =  PACK(InData%C2_42 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_42)
  ENDIF
  IF ( ALLOCATED(InData%D2_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_11))-1 ) =  PACK(InData%D2_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_11)
  ENDIF
  IF ( ALLOCATED(InData%D2_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_21))-1 ) =  PACK(InData%D2_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_21)
  ENDIF
  IF ( ALLOCATED(InData%D2_32) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_32))-1 ) =  PACK(InData%D2_32 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_32)
  ENDIF
  IF ( ALLOCATED(InData%D2_42) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_42))-1 ) =  PACK(InData%D2_42 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_42)
  ENDIF
  IF ( ALLOCATED(InData%Abar_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Abar_21))-1 ) =  PACK(InData%Abar_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Abar_21)
  ENDIF
  IF ( ALLOCATED(InData%Abar_22) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Abar_22))-1 ) =  PACK(InData%Abar_22 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Abar_22)
  ENDIF
  IF ( ALLOCATED(InData%Bbar_13) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Bbar_13))-1 ) =  PACK(InData%Bbar_13 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Bbar_13)
  ENDIF
  IF ( ALLOCATED(InData%Bbar_23) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Bbar_23))-1 ) =  PACK(InData%Bbar_23 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Bbar_23)
  ENDIF
  IF ( ALLOCATED(InData%Bbar_24) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Bbar_24))-1 ) =  PACK(InData%Bbar_24 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Bbar_24)
  ENDIF
  IF ( ALLOCATED(InData%Fbar_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fbar_21))-1 ) =  PACK(InData%Fbar_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fbar_21)
  ENDIF
  IF ( ALLOCATED(InData%MBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBB))-1 ) =  PACK(InData%MBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBB)
  ENDIF
  IF ( ALLOCATED(InData%KBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%KBB))-1 ) =  PACK(InData%KBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%KBB)
  ENDIF
  IF ( ALLOCATED(InData%MBM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBM))-1 ) =  PACK(InData%MBM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBM)
  ENDIF
  IF ( ALLOCATED(InData%PHI_R) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PHI_R))-1 ) =  PACK(InData%PHI_R ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PHI_R)
  ENDIF
  IF ( ALLOCATED(InData%PHI_M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PHI_M))-1 ) =  PACK(InData%PHI_M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PHI_M)
  ENDIF
  IF ( ALLOCATED(InData%TIreact) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TIreact))-1 ) =  PACK(InData%TIreact ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TIreact)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NModes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Elems) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Elems))-1 ) = PACK(InData%Elems ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Elems)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%qmL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%uL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_L )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofI )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofR )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofC )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NReact )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Reacts) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Reacts))-1 ) = PACK(InData%Reacts ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Reacts)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Nmembers )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TPdofL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%URbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%URdotdotL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UdotdotL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Y2L )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IntMethod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NAvgEls )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%IDI) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDI))-1 ) = PACK(InData%IDI ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDI)
  ENDIF
  IF ( ALLOCATED(InData%IDR) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDR))-1 ) = PACK(InData%IDR ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDR)
  ENDIF
  IF ( ALLOCATED(InData%IDL) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDL))-1 ) = PACK(InData%IDL ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDL)
  ENDIF
  IF ( ALLOCATED(InData%IDC) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDC))-1 ) = PACK(InData%IDC ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDC)
  ENDIF
  IF ( ALLOCATED(InData%IDY) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDY))-1 ) = PACK(InData%IDY ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDY)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMOutputs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SDDeltaT )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnJckF )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = 1, SIZE(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 ) = Re_MoutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 ) = Db_MoutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 ) = Int_MoutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst_Buf) )  DEALLOCATE(Re_MoutLst_Buf)
  IF( ALLOCATED(Db_MoutLst_Buf) )  DEALLOCATE(Db_MoutLst_Buf)
  IF( ALLOCATED(Int_MoutLst_Buf) ) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = 1, SIZE(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 ) = Re_MoutLst2_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 ) = Db_MoutLst2_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 ) = Int_MoutLst2_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst2_Buf) )  DEALLOCATE(Re_MoutLst2_Buf)
  IF( ALLOCATED(Db_MoutLst2_Buf) )  DEALLOCATE(Db_MoutLst2_Buf)
  IF( ALLOCATED(Int_MoutLst2_Buf) ) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = 1, SIZE(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 ) = Re_MoutLst3_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 ) = Db_MoutLst3_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 ) = Int_MoutLst3_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst3_Buf) )  DEALLOCATE(Re_MoutLst3_Buf)
  IF( ALLOCATED(Db_MoutLst3_Buf) )  DEALLOCATE(Db_MoutLst3_Buf)
  IF( ALLOCATED(Int_MoutLst3_Buf) ) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = 1, SIZE(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, OnlySize ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 ) = Re_ElemProps_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 ) = Db_ElemProps_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 ) = Int_ElemProps_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  IF( ALLOCATED(Re_ElemProps_Buf) )  DEALLOCATE(Re_ElemProps_Buf)
  IF( ALLOCATED(Db_ElemProps_Buf) )  DEALLOCATE(Db_ElemProps_Buf)
  IF( ALLOCATED(Int_ElemProps_Buf) ) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = 1, SIZE(InData%OutParam,1)
  CALL SD_Packoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllInt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllDims )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutDec )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxOUtPts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackParam

 SUBROUTINE SD_UnpackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%A_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%A_21,1),SIZE(OutData%A_21,2))); mask2 = .TRUE.
    OutData%A_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%A_21))-1 ),mask2,OutData%A_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%A_21)
  ENDIF
  IF ( ALLOCATED(OutData%A_22) ) THEN
  ALLOCATE(mask2(SIZE(OutData%A_22,1),SIZE(OutData%A_22,2))); mask2 = .TRUE.
    OutData%A_22 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%A_22))-1 ),mask2,OutData%A_22)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%A_22)
  ENDIF
  IF ( ALLOCATED(OutData%B_23) ) THEN
  ALLOCATE(mask2(SIZE(OutData%B_23,1),SIZE(OutData%B_23,2))); mask2 = .TRUE.
    OutData%B_23 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%B_23))-1 ),mask2,OutData%B_23)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%B_23)
  ENDIF
  IF ( ALLOCATED(OutData%B_24) ) THEN
  ALLOCATE(mask2(SIZE(OutData%B_24,1),SIZE(OutData%B_24,2))); mask2 = .TRUE.
    OutData%B_24 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%B_24))-1 ),mask2,OutData%B_24)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%B_24)
  ENDIF
  IF ( ALLOCATED(OutData%FX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FX,1))); mask1 = .TRUE.
    OutData%FX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FX)
  ENDIF
  IF ( ALLOCATED(OutData%C1_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_11,1),SIZE(OutData%C1_11,2))); mask2 = .TRUE.
    OutData%C1_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_11))-1 ),mask2,OutData%C1_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_11)
  ENDIF
  IF ( ALLOCATED(OutData%C1_12) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_12,1),SIZE(OutData%C1_12,2))); mask2 = .TRUE.
    OutData%C1_12 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_12))-1 ),mask2,OutData%C1_12)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_12)
  ENDIF
  IF ( ALLOCATED(OutData%D1_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_11,1),SIZE(OutData%D1_11,2))); mask2 = .TRUE.
    OutData%D1_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_11))-1 ),mask2,OutData%D1_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_11)
  ENDIF
  IF ( ALLOCATED(OutData%D1_13) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_13,1),SIZE(OutData%D1_13,2))); mask2 = .TRUE.
    OutData%D1_13 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_13))-1 ),mask2,OutData%D1_13)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_13)
  ENDIF
  IF ( ALLOCATED(OutData%D1_14) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_14,1),SIZE(OutData%D1_14,2))); mask2 = .TRUE.
    OutData%D1_14 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_14))-1 ),mask2,OutData%D1_14)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_14)
  ENDIF
  IF ( ALLOCATED(OutData%FY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FY,1))); mask1 = .TRUE.
    OutData%FY = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FY)
  ENDIF
  IF ( ALLOCATED(OutData%C2_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_21,1),SIZE(OutData%C2_21,2))); mask2 = .TRUE.
    OutData%C2_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_21))-1 ),mask2,OutData%C2_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_21)
  ENDIF
  IF ( ALLOCATED(OutData%C2_42) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_42,1),SIZE(OutData%C2_42,2))); mask2 = .TRUE.
    OutData%C2_42 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_42))-1 ),mask2,OutData%C2_42)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_42)
  ENDIF
  IF ( ALLOCATED(OutData%D2_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_11,1),SIZE(OutData%D2_11,2))); mask2 = .TRUE.
    OutData%D2_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_11))-1 ),mask2,OutData%D2_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_11)
  ENDIF
  IF ( ALLOCATED(OutData%D2_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_21,1),SIZE(OutData%D2_21,2))); mask2 = .TRUE.
    OutData%D2_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_21))-1 ),mask2,OutData%D2_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_21)
  ENDIF
  IF ( ALLOCATED(OutData%D2_32) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_32,1),SIZE(OutData%D2_32,2))); mask2 = .TRUE.
    OutData%D2_32 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_32))-1 ),mask2,OutData%D2_32)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_32)
  ENDIF
  IF ( ALLOCATED(OutData%D2_42) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_42,1),SIZE(OutData%D2_42,2))); mask2 = .TRUE.
    OutData%D2_42 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_42))-1 ),mask2,OutData%D2_42)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_42)
  ENDIF
  IF ( ALLOCATED(OutData%Abar_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Abar_21,1),SIZE(OutData%Abar_21,2))); mask2 = .TRUE.
    OutData%Abar_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Abar_21))-1 ),mask2,OutData%Abar_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Abar_21)
  ENDIF
  IF ( ALLOCATED(OutData%Abar_22) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Abar_22,1),SIZE(OutData%Abar_22,2))); mask2 = .TRUE.
    OutData%Abar_22 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Abar_22))-1 ),mask2,OutData%Abar_22)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Abar_22)
  ENDIF
  IF ( ALLOCATED(OutData%Bbar_13) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Bbar_13,1),SIZE(OutData%Bbar_13,2))); mask2 = .TRUE.
    OutData%Bbar_13 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Bbar_13))-1 ),mask2,OutData%Bbar_13)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Bbar_13)
  ENDIF
  IF ( ALLOCATED(OutData%Bbar_23) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Bbar_23,1),SIZE(OutData%Bbar_23,2))); mask2 = .TRUE.
    OutData%Bbar_23 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Bbar_23))-1 ),mask2,OutData%Bbar_23)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Bbar_23)
  ENDIF
  IF ( ALLOCATED(OutData%Bbar_24) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Bbar_24,1),SIZE(OutData%Bbar_24,2))); mask2 = .TRUE.
    OutData%Bbar_24 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Bbar_24))-1 ),mask2,OutData%Bbar_24)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Bbar_24)
  ENDIF
  IF ( ALLOCATED(OutData%Fbar_21) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fbar_21,1))); mask1 = .TRUE.
    OutData%Fbar_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fbar_21))-1 ),mask1,OutData%Fbar_21)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fbar_21)
  ENDIF
  IF ( ALLOCATED(OutData%MBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBB,1),SIZE(OutData%MBB,2))); mask2 = .TRUE.
    OutData%MBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBB))-1 ),mask2,OutData%MBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBB)
  ENDIF
  IF ( ALLOCATED(OutData%KBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%KBB,1),SIZE(OutData%KBB,2))); mask2 = .TRUE.
    OutData%KBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%KBB))-1 ),mask2,OutData%KBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%KBB)
  ENDIF
  IF ( ALLOCATED(OutData%MBM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBM,1),SIZE(OutData%MBM,2))); mask2 = .TRUE.
    OutData%MBM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBM))-1 ),mask2,OutData%MBM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBM)
  ENDIF
  IF ( ALLOCATED(OutData%PHI_R) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PHI_R,1),SIZE(OutData%PHI_R,2))); mask2 = .TRUE.
    OutData%PHI_R = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PHI_R))-1 ),mask2,OutData%PHI_R)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PHI_R)
  ENDIF
  IF ( ALLOCATED(OutData%PHI_M) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PHI_M,1),SIZE(OutData%PHI_M,2))); mask2 = .TRUE.
    OutData%PHI_M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PHI_M))-1 ),mask2,OutData%PHI_M)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PHI_M)
  ENDIF
  IF ( ALLOCATED(OutData%TIreact) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TIreact,1),SIZE(OutData%TIreact,2))); mask2 = .TRUE.
    OutData%TIreact = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TIreact))-1 ),mask2,OutData%TIreact)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TIreact)
  ENDIF
  OutData%NModes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Elems) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Elems,1),SIZE(OutData%Elems,2))); mask2 = .TRUE.
    OutData%Elems = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Elems))-1 ),mask2,OutData%Elems)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Elems)
  ENDIF
  OutData%qmL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%uL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_L = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofI = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofR = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofC = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NReact = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Reacts) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Reacts,1),SIZE(OutData%Reacts,2))); mask2 = .TRUE.
    OutData%Reacts = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Reacts))-1 ),mask2,OutData%Reacts)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Reacts)
  ENDIF
  OutData%Nmembers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TPdofL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%URbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%URdotdotL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UdotdotL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Y2L = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%IntMethod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NAvgEls = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%IDI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDI,1))); mask1 = .TRUE.
    OutData%IDI = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDI))-1 ),mask1,OutData%IDI)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDI)
  ENDIF
  IF ( ALLOCATED(OutData%IDR) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDR,1))); mask1 = .TRUE.
    OutData%IDR = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDR))-1 ),mask1,OutData%IDR)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDR)
  ENDIF
  IF ( ALLOCATED(OutData%IDL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDL,1))); mask1 = .TRUE.
    OutData%IDL = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDL))-1 ),mask1,OutData%IDL)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDL)
  ENDIF
  IF ( ALLOCATED(OutData%IDC) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDC,1))); mask1 = .TRUE.
    OutData%IDC = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDC))-1 ),mask1,OutData%IDC)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDC)
  ENDIF
  IF ( ALLOCATED(OutData%IDY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDY,1))); mask1 = .TRUE.
    OutData%IDY = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDY))-1 ),mask1,OutData%IDY)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDY)
  ENDIF
  OutData%NMOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%SDDeltaT = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnJckF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = 1, SIZE(OutData%MoutLst,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    Re_MoutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    Db_MoutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    Int_MoutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  CALL SD_Unpackmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg ) ! MoutLst 
ENDDO
DO i1 = 1, SIZE(OutData%MoutLst2,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    Re_MoutLst2_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    Db_MoutLst2_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    Int_MoutLst2_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  CALL SD_Unpackmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg ) ! MoutLst2 
ENDDO
DO i1 = 1, SIZE(OutData%MoutLst3,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    Re_MoutLst3_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    Db_MoutLst3_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    Int_MoutLst3_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  CALL SD_Unpackmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg ) ! MoutLst3 
ENDDO
DO i1 = 1, SIZE(OutData%ElemProps,1)
 ! first call SD_Packelemproptype to get correctly sized buffers for unpacking
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    Re_ElemProps_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    Db_ElemProps_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    Int_ElemProps_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  CALL SD_Unpackelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg ) ! ElemProps 
ENDDO
DO i1 = 1, SIZE(OutData%OutParam,1)
 ! first call SD_Packoutvar_type to get correctly sized buffers for unpacking
  CALL SD_Packoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL SD_Unpackoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  OutData%OutAllInt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutAllDims = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutDec = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MaxOUtPts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackParam

 SUBROUTINE SD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_inputtype), INTENT(INOUT) :: SrcInputData
  TYPE(SD_inputtype), INTENT(INOUT) :: DstInputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshCopy( SrcInputData%TPMesh, DstInputData%TPMesh, CtrlCode, ErrStat, ErrMsg )
  CALL MeshCopy( SrcInputData%LMesh, DstInputData%LMesh, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopyInput

 SUBROUTINE SD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SD_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%TPMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%LMesh, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyInput

 SUBROUTINE SD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Db_TPMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Int_TPMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_TPMesh_Buf ) ! TPMesh
  IF(ALLOCATED(Re_TPMesh_Buf))  DEALLOCATE(Re_TPMesh_Buf)
  IF(ALLOCATED(Db_TPMesh_Buf))  DEALLOCATE(Db_TPMesh_Buf)
  IF(ALLOCATED(Int_TPMesh_Buf)) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Db_LMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Int_LMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LMesh_Buf ) ! LMesh
  IF(ALLOCATED(Re_LMesh_Buf))  DEALLOCATE(Re_LMesh_Buf)
  IF(ALLOCATED(Db_LMesh_Buf))  DEALLOCATE(Db_LMesh_Buf)
  IF(ALLOCATED(Int_LMesh_Buf)) DEALLOCATE(Int_LMesh_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 ) = Re_TPMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 ) = Db_TPMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 ) = Int_TPMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 ) = Re_LMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 ) = Db_LMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 ) = Int_LMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
 END SUBROUTINE SD_PackInput

 SUBROUTINE SD_UnpackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    Re_TPMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    Db_TPMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    Int_TPMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg ) ! TPMesh 
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    Re_LMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    Db_LMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    Int_LMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg ) ! LMesh 
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackInput

 SUBROUTINE SD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_outputtype), INTENT(INOUT) :: SrcOutputData
  TYPE(SD_outputtype), INTENT(INOUT) :: DstOutputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshCopy( SrcOutputData%Y1Mesh, DstOutputData%Y1Mesh, CtrlCode, ErrStat, ErrMsg )
  CALL MeshCopy( SrcOutputData%Y2Mesh, DstOutputData%Y2Mesh, CtrlCode, ErrStat, ErrMsg )
IF ( ALLOCATED( SrcOutputData%WriteOutput ) ) THEN
  i1 = SIZE(SrcOutputData%WriteOutput,1)
  IF (.NOT.ALLOCATED(DstOutputData%WriteOutput)) ALLOCATE(DstOutputData%WriteOutput(i1))
  DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE SD_CopyOutput

 SUBROUTINE SD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SD_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%Y1Mesh, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%Y2Mesh, ErrStat, ErrMsg )
  IF ( ALLOCATED(OutputData%WriteOutput) ) DEALLOCATE(OutputData%WriteOutput)
 END SUBROUTINE SD_DestroyOutput

 SUBROUTINE SD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y2Mesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Db_Y1Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Int_Y1Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y1Mesh_Buf ) ! Y1Mesh
  IF(ALLOCATED(Re_Y1Mesh_Buf))  DEALLOCATE(Re_Y1Mesh_Buf)
  IF(ALLOCATED(Db_Y1Mesh_Buf))  DEALLOCATE(Db_Y1Mesh_Buf)
  IF(ALLOCATED(Int_Y1Mesh_Buf)) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Db_Y2Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Int_Y2Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y2Mesh_Buf ) ! Y2Mesh
  IF(ALLOCATED(Re_Y2Mesh_Buf))  DEALLOCATE(Re_Y2Mesh_Buf)
  IF(ALLOCATED(Db_Y2Mesh_Buf))  DEALLOCATE(Db_Y2Mesh_Buf)
  IF(ALLOCATED(Int_Y2Mesh_Buf)) DEALLOCATE(Int_Y2Mesh_Buf)
  Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 ) = Re_Y1Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 ) = Db_Y1Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 ) = Int_Y1Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 ) = Re_Y2Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 ) = Db_Y2Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 ) = Int_Y2Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE SD_PackOutput

 SUBROUTINE SD_UnpackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y2Mesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    Re_Y1Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    Db_Y1Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    Int_Y1Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg ) ! Y1Mesh 
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    Re_Y2Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    Db_Y2Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    Int_Y2Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg ) ! Y2Mesh 
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackOutput

 SUBROUTINE SD_CopydYdu( SrcdYduData, DstdYduData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: SrcdYduData
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: DstdYduData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyInput( SrcdYduData%DummyOutput, DstdYduData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydYdu

 SUBROUTINE SD_DestroydYdu( dYduData, ErrStat, ErrMsg )
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: dYduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dYduData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydYdu

 SUBROUTINE SD_PackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialoutputpinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_PackdYdu

 SUBROUTINE SD_UnpackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnpackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackdYdu

 SUBROUTINE SD_CopydXdu( SrcdXduData, DstdXduData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: SrcdXduData
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: DstdXduData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyInput( SrcdXduData%DummyContState, DstdXduData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydXdu

 SUBROUTINE SD_DestroydXdu( dXduData, ErrStat, ErrMsg )
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: dXduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXduData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXdu

 SUBROUTINE SD_PackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialcontstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_PackdXdu

 SUBROUTINE SD_UnpackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnpackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackdXdu

 SUBROUTINE SD_CopydXddu( SrcdXdduData, DstdXdduData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: SrcdXdduData
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: DstdXdduData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyInput( SrcdXdduData%DummyDiscState, DstdXdduData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydXddu

 SUBROUTINE SD_DestroydXddu( dXdduData, ErrStat, ErrMsg )
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: dXdduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXdduData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXddu

 SUBROUTINE SD_PackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialdiscstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_PackdXddu

 SUBROUTINE SD_UnpackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnpackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackdXddu

 SUBROUTINE SD_CopydZdu( SrcdZduData, DstdZduData, CtrlCode, ErrStat, ErrMsg )
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: SrcdZduData
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: DstdZduData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyInput( SrcdZduData%DummyConstrState, DstdZduData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydZdu

 SUBROUTINE SD_DestroydZdu( dZduData, ErrStat, ErrMsg )
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: dZduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dZduData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydZdu

 SUBROUTINE SD_PackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialconstrstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_PackdZdu

 SUBROUTINE SD_UnpackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnpackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnpackdZdu

 SUBROUTINE SD_Copypartialoutputpcontstatetype( SrcpartialoutputpcontstatetypeData, DstpartialoutputpcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: SrcpartialoutputpcontstatetypeData
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: DstpartialoutputpcontstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyContState( SrcpartialoutputpcontstatetypeData%DummyOutput, DstpartialoutputpcontstatetypeData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialoutputpcontstatetype

 SUBROUTINE SD_Destroypartialoutputpcontstatetype( partialoutputpcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: partialoutputpcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialoutputpcontstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpcontstatetype

 SUBROUTINE SD_Packpartialoutputpcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpcontstatetype

 SUBROUTINE SD_Unpackpartialoutputpcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnpackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialoutputpcontstatetype

 SUBROUTINE SD_Copypartialcontstatepcontstatetype( SrcpartialcontstatepcontstatetypeData, DstpartialcontstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: SrcpartialcontstatepcontstatetypeData
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: DstpartialcontstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyContState( SrcpartialcontstatepcontstatetypeData%DummyContState, DstpartialcontstatepcontstatetypeData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialcontstatepcontstatetype

 SUBROUTINE SD_Destroypartialcontstatepcontstatetype( partialcontstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: partialcontstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialcontstatepcontstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepcontstatetype

 SUBROUTINE SD_Packpartialcontstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepcontstatetype

 SUBROUTINE SD_Unpackpartialcontstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnpackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialcontstatepcontstatetype

 SUBROUTINE SD_Copypartialdiscstatepcontstatetype( SrcpartialdiscstatepcontstatetypeData, DstpartialdiscstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: SrcpartialdiscstatepcontstatetypeData
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: DstpartialdiscstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyContState( SrcpartialdiscstatepcontstatetypeData%DummyDiscState, DstpartialdiscstatepcontstatetypeData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialdiscstatepcontstatetype

 SUBROUTINE SD_Destroypartialdiscstatepcontstatetype( partialdiscstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: partialdiscstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialdiscstatepcontstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepcontstatetype

 SUBROUTINE SD_Packpartialdiscstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepcontstatetype

 SUBROUTINE SD_Unpackpartialdiscstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnpackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialdiscstatepcontstatetype

 SUBROUTINE SD_Copypartialconstrstatepcontstatetype( SrcpartialconstrstatepcontstatetypeData, DstpartialconstrstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: SrcpartialconstrstatepcontstatetypeData
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: DstpartialconstrstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyContState( SrcpartialconstrstatepcontstatetypeData%DummyConstrState, DstpartialconstrstatepcontstatetypeData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialconstrstatepcontstatetype

 SUBROUTINE SD_Destroypartialconstrstatepcontstatetype( partialconstrstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: partialconstrstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialconstrstatepcontstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepcontstatetype

 SUBROUTINE SD_Packpartialconstrstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepcontstatetype

 SUBROUTINE SD_Unpackpartialconstrstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnpackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialconstrstatepcontstatetype

 SUBROUTINE SD_Copypartialoutputpdiscstatetype( SrcpartialoutputpdiscstatetypeData, DstpartialoutputpdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: SrcpartialoutputpdiscstatetypeData
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: DstpartialoutputpdiscstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyDiscState( SrcpartialoutputpdiscstatetypeData%DummyOutput, DstpartialoutputpdiscstatetypeData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialoutputpdiscstatetype

 SUBROUTINE SD_Destroypartialoutputpdiscstatetype( partialoutputpdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: partialoutputpdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialoutputpdiscstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpdiscstatetype

 SUBROUTINE SD_Packpartialoutputpdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpdiscstatetype

 SUBROUTINE SD_Unpackpartialoutputpdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnpackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialoutputpdiscstatetype

 SUBROUTINE SD_Copypartialcontstatepdiscstatetype( SrcpartialcontstatepdiscstatetypeData, DstpartialcontstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: SrcpartialcontstatepdiscstatetypeData
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: DstpartialcontstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyDiscState( SrcpartialcontstatepdiscstatetypeData%DummyContState, DstpartialcontstatepdiscstatetypeData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialcontstatepdiscstatetype

 SUBROUTINE SD_Destroypartialcontstatepdiscstatetype( partialcontstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: partialcontstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialcontstatepdiscstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepdiscstatetype

 SUBROUTINE SD_Packpartialcontstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepdiscstatetype

 SUBROUTINE SD_Unpackpartialcontstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnpackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialcontstatepdiscstatetype

 SUBROUTINE SD_Copypartialdiscstatepdiscstatetype( SrcpartialdiscstatepdiscstatetypeData, DstpartialdiscstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: SrcpartialdiscstatepdiscstatetypeData
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: DstpartialdiscstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyDiscState( SrcpartialdiscstatepdiscstatetypeData%DummyDiscState, DstpartialdiscstatepdiscstatetypeData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialdiscstatepdiscstatetype

 SUBROUTINE SD_Destroypartialdiscstatepdiscstatetype( partialdiscstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: partialdiscstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialdiscstatepdiscstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepdiscstatetype

 SUBROUTINE SD_Packpartialdiscstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepdiscstatetype

 SUBROUTINE SD_Unpackpartialdiscstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnpackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialdiscstatepdiscstatetype

 SUBROUTINE SD_Copypartialconstrstatepdiscstatetype( SrcpartialconstrstatepdiscstatetypeData, DstpartialconstrstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: SrcpartialconstrstatepdiscstatetypeData
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: DstpartialconstrstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyDiscState( SrcpartialconstrstatepdiscstatetypeData%DummyConstrState, DstpartialconstrstatepdiscstatetypeData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialconstrstatepdiscstatetype

 SUBROUTINE SD_Destroypartialconstrstatepdiscstatetype( partialconstrstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: partialconstrstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialconstrstatepdiscstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepdiscstatetype

 SUBROUTINE SD_Packpartialconstrstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepdiscstatetype

 SUBROUTINE SD_Unpackpartialconstrstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnpackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialconstrstatepdiscstatetype

 SUBROUTINE SD_Copypartialoutputpconstrstatetype( SrcpartialoutputpconstrstatetypeData, DstpartialoutputpconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: SrcpartialoutputpconstrstatetypeData
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: DstpartialoutputpconstrstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyConstrState( SrcpartialoutputpconstrstatetypeData%DummyOutput, DstpartialoutputpconstrstatetypeData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialoutputpconstrstatetype

 SUBROUTINE SD_Destroypartialoutputpconstrstatetype( partialoutputpconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: partialoutputpconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialoutputpconstrstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpconstrstatetype

 SUBROUTINE SD_Packpartialoutputpconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpconstrstatetype

 SUBROUTINE SD_Unpackpartialoutputpconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnpackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialoutputpconstrstatetype

 SUBROUTINE SD_Copypartialcontstatepconstrstatetype( SrcpartialcontstatepconstrstatetypeData, DstpartialcontstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: SrcpartialcontstatepconstrstatetypeData
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: DstpartialcontstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyConstrState( SrcpartialcontstatepconstrstatetypeData%DummyContState, DstpartialcontstatepconstrstatetypeData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialcontstatepconstrstatetype

 SUBROUTINE SD_Destroypartialcontstatepconstrstatetype( partialcontstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: partialcontstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialcontstatepconstrstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepconstrstatetype

 SUBROUTINE SD_Packpartialcontstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepconstrstatetype

 SUBROUTINE SD_Unpackpartialcontstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnpackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialcontstatepconstrstatetype

 SUBROUTINE SD_Copypartialdiscstatepconstrstatetype( SrcpartialdiscstatepconstrstatetypeData, DstpartialdiscstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: SrcpartialdiscstatepconstrstatetypeData
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: DstpartialdiscstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyConstrState( SrcpartialdiscstatepconstrstatetypeData%DummyDiscState, DstpartialdiscstatepconstrstatetypeData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialdiscstatepconstrstatetype

 SUBROUTINE SD_Destroypartialdiscstatepconstrstatetype( partialdiscstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: partialdiscstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialdiscstatepconstrstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepconstrstatetype

 SUBROUTINE SD_Packpartialdiscstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepconstrstatetype

 SUBROUTINE SD_Unpackpartialdiscstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnpackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialdiscstatepconstrstatetype

 SUBROUTINE SD_Copypartialconstrstatepconstrstatetype( SrcpartialconstrstatepconstrstatetypeData, DstpartialconstrstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: SrcpartialconstrstatepconstrstatetypeData
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: DstpartialconstrstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_CopyConstrState( SrcpartialconstrstatepconstrstatetypeData%DummyConstrState, DstpartialconstrstatepconstrstatetypeData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialconstrstatepconstrstatetype

 SUBROUTINE SD_Destroypartialconstrstatepconstrstatetype( partialconstrstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: partialconstrstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialconstrstatepconstrstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepconstrstatetype

 SUBROUTINE SD_Packpartialconstrstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepconstrstatetype

 SUBROUTINE SD_Unpackpartialconstrstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnpackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpackpartialconstrstatepconstrstatetype

 SUBROUTINE SD_Pack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg, &
                     SizeOnly )
  TYPE(SD_InputType),           INTENT(INOUT) :: InData
  TYPE(SD_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(SD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(SD_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(SD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(SD_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(SD_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(  OUT) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(  OUT) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,  INTENT(  OUT) :: Int_RetAry(:)
  INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
  CHARACTER(*),                 INTENT(  OUT) :: ErrMsg
  LOGICAL, OPTIONAL,            INTENT(IN   ) :: SizeOnly
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  LOGICAL                                :: OnlySize ! if present and true, do not pack, just allocate buffers
    ! Executable statements
  ErrStat = ErrID_None
  ErrMsg  = ""
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred  = Re_Xferred - 1
  Db_Xferred  = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
  IF ( ALLOCATED( Re_RetAry ) ) DEALLOCATE( Re_RetAry ) ;
  IF ( Re_Xferred .GT. 0) ALLOCATE( Re_RetAry( Re_Xferred ) ) ;
  IF ( ALLOCATED( Db_RetAry ) ) DEALLOCATE( Db_RetAry ) ;
  IF ( Db_Xferred .GT. 0) ALLOCATE( Db_RetAry( Db_Xferred ) ) ;
  IF ( ALLOCATED( Int_RetAry ) ) DEALLOCATE( Int_RetAry ) ;
  IF ( Int_Xferred .GT. 0) ALLOCATE( Int_RetAry( Int_Xferred ) ) ;
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred   = Re_Xferred - 1
  Db_Xferred   = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
 END SUBROUTINE SD_Pack

 SUBROUTINE SD_Unpack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg )
  TYPE(SD_InputType),           INTENT(INOUT) :: InData
  TYPE(SD_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(SD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(SD_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(SD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(SD_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(SD_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(IN   ) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(IN   ) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,   INTENT(IN   ) :: Int_RetAry(:)
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Unpack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnpackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnpackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnpackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnpackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnpackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnpackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnpackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_Unpack


 SUBROUTINE SD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 TYPE(MeshType) :: tmpmesh
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr1       ! temporary for extrapolaton/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr2       ! temporary for extrapolation/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md1       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md3       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi1       ! temporary for extrapolaton/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi3       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: a0       ! temporary for extrapolaton/interpolation
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: a1       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: a2       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: a3       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: a4       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: a5       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we're going to subtract a constant from the times
    ! to check if this resolves some numerical issues later (when t gets large)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%TPMesh, u_out%TPMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%LMesh, u_out%LMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshPack(u(1)%TPMesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%TPMesh, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  a1 = -((t(2)*mr1 - t(1)*mr2)/(t(1) - t(2)))
  b1 = -((-mr1 + mr2)/(t(1) - t(2)))
  mr1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  a1 = -((t(2)*md1 - t(1)*md2)/(t(1) - t(2)))
  b1 = -((-md1 + md2)/(t(1) - t(2)))
  md1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%TPMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
  CALL MeshPack(u(1)%LMesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%LMesh, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  a1 = -((t(2)*mr1 - t(1)*mr2)/(t(1) - t(2)))
  b1 = -((-mr1 + mr2)/(t(1) - t(2)))
  mr1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  a1 = -((t(2)*md1 - t(1)*md2)/(t(1) - t(2)))
  b1 = -((-md1 + md2)/(t(1) - t(2)))
  md1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%LMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshPack(u(1)%TPMesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%TPMesh, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%TPMesh, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*mr2 &
      + t(2)**2*(t(3)*mr1 - t(1)*mr3)        &
      + t(2)*(-(t(3)**2*mr1) + t(1)**2*mr3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(mr1  - mr2) &
      + t(1)**2*(mr2 - mr3 ) + t(2)**2*(-mr1  &
      + mr3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  c1 = (t(3)*(-mr1 + mr2 ) &
      + t(2)*(mr1 - mr3 ) &
      + t(1)*(-mr2 + mr3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  mr1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*md2 &
      + t(2)**2*(t(3)*md1 - t(1)*md3)        &
      + t(2)*(-(t(3)**2*md1) + t(1)**2*md3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(md1  - md2) &
      + t(1)**2*(md2 - md3 ) + t(2)**2*(-md1  &
      + md3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
  c1 = (t(3)*(-md1 + md2 ) &
      + t(2)*(md1 - md3 ) &
      + t(1)*(-md2 + md3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  md1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%TPMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
  CALL MeshPack(u(1)%LMesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%LMesh, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%LMesh, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*mr2 &
      + t(2)**2*(t(3)*mr1 - t(1)*mr3)        &
      + t(2)*(-(t(3)**2*mr1) + t(1)**2*mr3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(mr1  - mr2) &
      + t(1)**2*(mr2 - mr3 ) + t(2)**2*(-mr1  &
      + mr3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  c1 = (t(3)*(-mr1 + mr2 ) &
      + t(2)*(mr1 - mr3 ) &
      + t(1)*(-mr2 + mr3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  mr1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*md2 &
      + t(2)**2*(t(3)*md1 - t(1)*md3)        &
      + t(2)*(-(t(3)**2*md1) + t(1)**2*md3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(md1  - md2) &
      + t(1)**2*(md2 - md3 ) + t(2)**2*(-md1  &
      + md3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
  c1 = (t(3)*(-md1 + md2 ) &
      + t(2)*(md1 - md3 ) &
      + t(1)*(-md2 + md3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  md1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%LMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Input_ExtrapInterp


 SUBROUTINE SD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 TYPE(MeshType) :: tmpmesh
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr1       ! temporary for extrapolaton/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr2       ! temporary for extrapolation/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md1       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md3       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi1       ! temporary for extrapolaton/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi3       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: a0       ! temporary for extrapolaton/interpolation
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: a1       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: a2       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: a3       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: a4       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: a5       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we're going to subtract a constant from the times
    ! to check if this resolves some numerical issues later (when t gets large)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%Y1Mesh, u_out%Y1Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%Y2Mesh, u_out%Y2Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  u_out%WriteOutput = u(1)%WriteOutput
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshPack(u(1)%Y1Mesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%Y1Mesh, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  a1 = -((t(2)*mr1 - t(1)*mr2)/(t(1) - t(2)))
  b1 = -((-mr1 + mr2)/(t(1) - t(2)))
  mr1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  a1 = -((t(2)*md1 - t(1)*md2)/(t(1) - t(2)))
  b1 = -((-md1 + md2)/(t(1) - t(2)))
  md1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%Y1Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
  CALL MeshPack(u(1)%Y2Mesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%Y2Mesh, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  a1 = -((t(2)*mr1 - t(1)*mr2)/(t(1) - t(2)))
  b1 = -((-mr1 + mr2)/(t(1) - t(2)))
  mr1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  a1 = -((t(2)*md1 - t(1)*md2)/(t(1) - t(2)))
  b1 = -((-md1 + md2)/(t(1) - t(2)))
  md1 = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%Y2Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
  ALLOCATE(a1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  a1 = -((t(2)*u(1)%WriteOutput - t(1)*u(2)%WriteOutput)/(t(1) - t(2)))
  b1 = -((-u(1)%WriteOutput + u(2)%WriteOutput)/(t(1) - t(2)))
  u_out%WriteOutput = a1 + b1 * t_out
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshPack(u(1)%Y1Mesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%Y1Mesh, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%Y1Mesh, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*mr2 &
      + t(2)**2*(t(3)*mr1 - t(1)*mr3)        &
      + t(2)*(-(t(3)**2*mr1) + t(1)**2*mr3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(mr1  - mr2) &
      + t(1)**2*(mr2 - mr3 ) + t(2)**2*(-mr1  &
      + mr3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  c1 = (t(3)*(-mr1 + mr2 ) &
      + t(2)*(mr1 - mr3 ) &
      + t(1)*(-mr2 + mr3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  mr1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*md2 &
      + t(2)**2*(t(3)*md1 - t(1)*md3)        &
      + t(2)*(-(t(3)**2*md1) + t(1)**2*md3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(md1  - md2) &
      + t(1)**2*(md2 - md3 ) + t(2)**2*(-md1  &
      + md3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
  c1 = (t(3)*(-md1 + md2 ) &
      + t(2)*(md1 - md3 ) &
      + t(1)*(-md2 + md3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  md1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%Y1Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
  CALL MeshPack(u(1)%Y2Mesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%Y2Mesh, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%Y2Mesh, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(a1(SIZE(mr1)))
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*mr2 &
      + t(2)**2*(t(3)*mr1 - t(1)*mr3)        &
      + t(2)*(-(t(3)**2*mr1) + t(1)**2*mr3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(mr1  - mr2) &
      + t(1)**2*(mr2 - mr3 ) + t(2)**2*(-mr1  &
      + mr3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  c1 = (t(3)*(-mr1 + mr2 ) &
      + t(2)*(mr1 - mr3 ) &
      + t(1)*(-mr2 + mr3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  mr1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(a1(SIZE(md1)))
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*md2 &
      + t(2)**2*(t(3)*md1 - t(1)*md3)        &
      + t(2)*(-(t(3)**2*md1) + t(1)**2*md3 ))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(md1  - md2) &
      + t(1)**2*(md2 - md3 ) + t(2)**2*(-md1  &
      + md3 ))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
  c1 = (t(3)*(-md1 + md2 ) &
      + t(2)*(md1 - md3 ) &
      + t(1)*(-md2 + md3 ))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  md1 = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%Y2Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
  ALLOCATE(a1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  a1 = (t(1)*t(3)*(-t(1) + t(3))*u(2)%WriteOutput &
      + t(2)**2*(t(3)*u(1)%WriteOutput - t(1)*u(3)%WriteOutput)        &
      + t(2)*(-(t(3)**2*u(1)%WriteOutput) + t(1)**2*u(3)%WriteOutput))                        &
      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) &
      + t(1)**2*(u(2)%WriteOutput - u(3)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput &
      + u(3)%WriteOutput))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
  c1 = (t(3)*(-u(1)%WriteOutput + u(2)%WriteOutput) &
      + t(2)*(u(1)%WriteOutput - u(3)%WriteOutput) &
      + t(1)*(-u(2)%WriteOutput + u(3)%WriteOutput))  &
      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
  u_out%WriteOutput = a1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(a1)
  DEALLOCATE(b1)
  DEALLOCATE(c1)
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Output_ExtrapInterp

END MODULE SubDyn_Types
!ENDOFREGISTRYGENERATEDFILE
