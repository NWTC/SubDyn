!STARTOFREGISTRYGENERATEDFILE './SubDyn_Types.f90'

! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
!*********************************************************************************************************************************
! SubDyn_Types
!.................................................................................................................................
! This file is part of SubDyn.
!
! Copyright (C) 2012, 2013 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE SubDyn_Types
! This module contains all of the user-defined types needed in SubDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  MeshAuxDataType  =======
  TYPE, PUBLIC :: MeshAuxDataType
    INTEGER(IntKi)  :: MemberID 
    INTEGER(IntKi)  :: NOutCnt 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeCnt 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeIDs 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmIDs 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmNds 
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmID2s 
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmNd2s 
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Me 
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Ke 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Fg 
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Me2 
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Ke2 
    REAL(ReKi) , DIMENSION(1:12,1:2)  :: Fg2 
  END TYPE MeshAuxDataType
! =======================
! =========  ElemPropType  =======
  TYPE, PUBLIC :: ElemPropType
    REAL(ReKi)  :: Area 
    REAL(ReKi)  :: Length 
    REAL(ReKi)  :: Ixx 
    REAL(ReKi)  :: Iyy 
    REAL(ReKi)  :: Jzz 
    LOGICAL  :: Shear 
    REAL(ReKi)  :: Kappa 
    REAL(ReKi)  :: YoungE 
    REAL(ReKi)  :: ShearG 
    REAL(ReKi)  :: Rho 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: DirCos 
  END TYPE ElemPropType
! =======================
! =========  SD_InitInputType  =======
  TYPE, PUBLIC :: SD_InitInputType
    CHARACTER(1024)  :: SDInputFile 
    REAL(ReKi)  :: g 
    REAL(ReKi)  :: WtrDpth 
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint 
    REAL(ReKi)  :: SubRotateZ 
    CHARACTER(1024)  :: SubDynSum 
    CHARACTER(1024)  :: RootName 
    REAL(DbKi)  :: DT 
    INTEGER(IntKi)  :: ErrStat 
    INTEGER(IntKi)  :: NJoints 
    INTEGER(IntKi)  :: JointsCol = 4 
    INTEGER(IntKi)  :: MembersCol = 5 
    INTEGER(IntKi)  :: NPropSets 
    INTEGER(IntKi)  :: PropSetsCol = 6 
    INTEGER(IntKi)  :: NXPropSets 
    INTEGER(IntKi)  :: XPropSetsCol = 10 
    INTEGER(IntKi)  :: ReactCol = 7 
    INTEGER(IntKi)  :: NInterf 
    INTEGER(IntKi)  :: InterfCol = 7 
    INTEGER(IntKi)  :: NCMass 
    INTEGER(IntKi)  :: CMassCol = 5 
    INTEGER(IntKi)  :: NCOSMs 
    INTEGER(IntKi)  :: COSMsCol = 10 
    INTEGER(IntKi)  :: FEMMod 
    INTEGER(IntKi)  :: NDiv 
    LOGICAL  :: CBMod 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Joints 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSets 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XPropSets 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: COSMs 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CMass 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: JDampings 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Members 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Interf 
    INTEGER(IntKi)  :: NNode 
    INTEGER(IntKi)  :: NElem 
    INTEGER(IntKi)  :: NProp 
    INTEGER(IntKi)  :: TDOF 
    INTEGER(IntKi)  :: MaxMemJnt = 10 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Props 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: K 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: M 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FG 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ElemProps 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: BCs 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: IntFc 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: MemberNodes 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnN 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnE 
    LOGICAL  :: SSSum 
    INTEGER(IntKi)  :: UnSum 
  END TYPE SD_InitInputType
! =======================
! =========  SD_InitOutputType  =======
  TYPE, PUBLIC :: SD_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt 
    TYPE(ProgDesc)  :: Ver 
    INTEGER(IntKi)  :: MaxOutChs = 2000 
    LOGICAL  :: TabDelim 
    LOGICAL  :: OutCOSM 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: SSOutList 
  END TYPE SD_InitOutputType
! =======================
! =========  SD_ContinuousStateType  =======
  TYPE, PUBLIC :: SD_ContinuousStateType
    REAL(ReKi)  :: DummyContState 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qm 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdotdot 
  END TYPE SD_ContinuousStateType
! =======================
! =========  SD_DiscreteStateType  =======
  TYPE, PUBLIC :: SD_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState 
  END TYPE SD_DiscreteStateType
! =======================
! =========  SD_ConstraintStateType  =======
  TYPE, PUBLIC :: SD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState 
  END TYPE SD_ConstraintStateType
! =======================
! =========  SD_OtherStateType  =======
  TYPE, PUBLIC :: SD_OtherStateType
    TYPE(SD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: xdot 
    INTEGER(IntKi)  :: n 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Udotdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y2 
  END TYPE SD_OtherStateType
! =======================
! =========  SD_OutVar_Type  =======
  TYPE, PUBLIC :: SD_OutVar_Type
    INTEGER(IntKi)  :: Indx 
    INTEGER(IntKi)  :: SignM 
    CHARACTER(10)  :: Units 
    CHARACTER(10)  :: Name 
  END TYPE SD_OutVar_Type
! =======================
! =========  SD_ParameterType  =======
  TYPE, PUBLIC :: SD_ParameterType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A_22 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: B_23 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: B_24 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_11 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_12 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_11 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_13 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_14 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FY 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_42 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_11 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_32 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_42 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cbar_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cbar_22 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dbar_13 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dbar_23 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dbar_24 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Fbar_21 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBB 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KBB 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBM 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PHI_R 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PHI_M 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AM2InvJac 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TIreact 
    INTEGER(IntKi)  :: NModes 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Elems 
    INTEGER(IntKi)  :: qmL 
    INTEGER(IntKi)  :: uL 
    INTEGER(IntKi)  :: DofL 
    INTEGER(IntKi)  :: NNodes_I 
    INTEGER(IntKi)  :: NNodes_L 
    INTEGER(IntKi)  :: NNodes_RbarL 
    INTEGER(IntKi)  :: DofI 
    INTEGER(IntKi)  :: DofR 
    INTEGER(IntKi)  :: DofRbarL 
    INTEGER(IntKi)  :: DofC 
    INTEGER(IntKi)  :: NReact 
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Reacts 
    INTEGER(IntKi)  :: Nmembers 
    INTEGER(IntKi)  :: TPdofL = 6 
    INTEGER(IntKi)  :: URbarL 
    INTEGER(IntKi)  :: URdotdotL 
    INTEGER(IntKi)  :: UdotdotL 
    INTEGER(IntKi)  :: Y2L 
    INTEGER(IntKi)  :: IntMethod 
    INTEGER(IntKi)  :: NAvgEls = 2 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDI 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDR 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDL 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDY 
    INTEGER(IntKi)  :: NMOutputs 
    INTEGER(IntKi)  :: NumOuts 
    REAL(DbKi)  :: SDDeltaT 
    INTEGER(IntKi)  :: OutSwtch 
    INTEGER(IntKi)  :: UnJckF 
    CHARACTER(1)  :: Delim 
    CHARACTER(20)  :: OutFmt 
    CHARACTER(20)  :: OutSFmt 
    CHARACTER(1024)  :: OutJckF 
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst 
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst2 
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst3 
    TYPE(ElemPropType) , DIMENSION(:), ALLOCATABLE  :: ElemProps 
    TYPE(SD_OutVar_Type) , DIMENSION(:), ALLOCATABLE  :: OutParam 
    LOGICAL  :: OutAll 
    LOGICAL  :: OutReact 
    INTEGER(IntKi)  :: OutAllInt 
    INTEGER(IntKi)  :: OutAllDims 
    INTEGER(IntKi)  :: OutDec 
    INTEGER(IntKi)  :: MaxOUtPts 
  END TYPE SD_ParameterType
! =======================
! =========  SD_InputType  =======
  TYPE, PUBLIC :: SD_InputType
    TYPE(MeshType)  :: TPMesh 
    TYPE(MeshType)  :: LMesh 
  END TYPE SD_InputType
! =======================
! =========  SD_OutputType  =======
  TYPE, PUBLIC :: SD_OutputType
    TYPE(MeshType)  :: Y1Mesh 
    TYPE(MeshType)  :: Y2Mesh 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput 
  END TYPE SD_OutputType
! =======================
! =========  SD_PartialOutputPInputType  =======
  TYPE, PUBLIC :: SD_PartialOutputPInputType
    TYPE(SD_InputType)  :: DummyOutput 
  END TYPE SD_PartialOutputPInputType
! =======================
! =========  SD_PartialContStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialContStatePInputType
    TYPE(SD_InputType)  :: DummyContState 
  END TYPE SD_PartialContStatePInputType
! =======================
! =========  SD_PartialDiscStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePInputType
    TYPE(SD_InputType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePInputType
! =======================
! =========  SD_PartialConstrStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePInputType
    TYPE(SD_InputType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePInputType
! =======================
! =========  SD_PartialOutputPContStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPContStateType
    TYPE(SD_ContinuousStateType)  :: DummyOutput 
  END TYPE SD_PartialOutputPContStateType
! =======================
! =========  SD_PartialContStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyContState 
  END TYPE SD_PartialContStatePContStateType
! =======================
! =========  SD_PartialDiscStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePContStateType
! =======================
! =========  SD_PartialConstrStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePContStateType
! =======================
! =========  SD_PartialOutputPDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyOutput 
  END TYPE SD_PartialOutputPDiscStateType
! =======================
! =========  SD_PartialContStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyContState 
  END TYPE SD_PartialContStatePDiscStateType
! =======================
! =========  SD_PartialDiscStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePDiscStateType
! =======================
! =========  SD_PartialConstrStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePDiscStateType
! =======================
! =========  SD_PartialOutputPConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyOutput 
  END TYPE SD_PartialOutputPConstrStateType
! =======================
! =========  SD_PartialContStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyContState 
  END TYPE SD_PartialContStatePConstrStateType
! =======================
! =========  SD_PartialDiscStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyDiscState 
  END TYPE SD_PartialDiscStatePConstrStateType
! =======================
! =========  SD_PartialConstrStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyConstrState 
  END TYPE SD_PartialConstrStatePConstrStateType
! =======================
CONTAINS
 SUBROUTINE SD_Copymeshauxdatatype( SrcmeshauxdatatypeData, DstmeshauxdatatypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(meshauxdatatype), INTENT(INOUT) :: SrcmeshauxdatatypeData
   TYPE(meshauxdatatype), INTENT(INOUT) :: DstmeshauxdatatypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmeshauxdatatypeData%MemberID = SrcmeshauxdatatypeData%MemberID
   DstmeshauxdatatypeData%NOutCnt = SrcmeshauxdatatypeData%NOutCnt
IF (ALLOCATED(SrcmeshauxdatatypeData%NodeCnt)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%NodeCnt,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%NodeCnt,1)
   IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%NodeCnt)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%NodeCnt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_Copymeshauxdatatype: Error allocating DstmeshauxdatatypeData%NodeCnt.'
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%NodeCnt = SrcmeshauxdatatypeData%NodeCnt
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%NodeIDs)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%NodeIDs,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%NodeIDs,1)
   IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%NodeIDs)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%NodeIDs(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_Copymeshauxdatatype: Error allocating DstmeshauxdatatypeData%NodeIDs.'
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%NodeIDs = SrcmeshauxdatatypeData%NodeIDs
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%ElmIDs)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%ElmIDs,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%ElmIDs,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%ElmIDs,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%ElmIDs,2)
   IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%ElmIDs)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%ElmIDs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_Copymeshauxdatatype: Error allocating DstmeshauxdatatypeData%ElmIDs.'
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%ElmIDs = SrcmeshauxdatatypeData%ElmIDs
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%ElmNds)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%ElmNds,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%ElmNds,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%ElmNds,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%ElmNds,2)
   IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%ElmNds)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%ElmNds(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_Copymeshauxdatatype: Error allocating DstmeshauxdatatypeData%ElmNds.'
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%ElmNds = SrcmeshauxdatatypeData%ElmNds
ENDIF
   DstmeshauxdatatypeData%ElmID2s = SrcmeshauxdatatypeData%ElmID2s
   DstmeshauxdatatypeData%ElmNd2s = SrcmeshauxdatatypeData%ElmNd2s
IF (ALLOCATED(SrcmeshauxdatatypeData%Me)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%Me,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%Me,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%Me,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%Me,2)
   i3_l = LBOUND(SrcmeshauxdatatypeData%Me,3)
   i3_u = UBOUND(SrcmeshauxdatatypeData%Me,3)
   i4_l = LBOUND(SrcmeshauxdatatypeData%Me,4)
   i4_u = UBOUND(SrcmeshauxdatatypeData%Me,4)
   IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%Me)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%Me(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_Copymeshauxdatatype: Error allocating DstmeshauxdatatypeData%Me.'
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%Me = SrcmeshauxdatatypeData%Me
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%Ke)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%Ke,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%Ke,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%Ke,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%Ke,2)
   i3_l = LBOUND(SrcmeshauxdatatypeData%Ke,3)
   i3_u = UBOUND(SrcmeshauxdatatypeData%Ke,3)
   i4_l = LBOUND(SrcmeshauxdatatypeData%Ke,4)
   i4_u = UBOUND(SrcmeshauxdatatypeData%Ke,4)
   IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%Ke)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%Ke(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_Copymeshauxdatatype: Error allocating DstmeshauxdatatypeData%Ke.'
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%Ke = SrcmeshauxdatatypeData%Ke
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%Fg)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%Fg,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%Fg,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%Fg,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%Fg,2)
   i3_l = LBOUND(SrcmeshauxdatatypeData%Fg,3)
   i3_u = UBOUND(SrcmeshauxdatatypeData%Fg,3)
   IF (.NOT.ALLOCATED(DstmeshauxdatatypeData%Fg)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%Fg(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_Copymeshauxdatatype: Error allocating DstmeshauxdatatypeData%Fg.'
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%Fg = SrcmeshauxdatatypeData%Fg
ENDIF
   DstmeshauxdatatypeData%Me2 = SrcmeshauxdatatypeData%Me2
   DstmeshauxdatatypeData%Ke2 = SrcmeshauxdatatypeData%Ke2
   DstmeshauxdatatypeData%Fg2 = SrcmeshauxdatatypeData%Fg2
 END SUBROUTINE SD_Copymeshauxdatatype

 SUBROUTINE SD_Destroymeshauxdatatype( meshauxdatatypeData, ErrStat, ErrMsg )
  TYPE(meshauxdatatype), INTENT(INOUT) :: meshauxdatatypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(meshauxdatatypeData%NodeCnt)) THEN
   DEALLOCATE(meshauxdatatypeData%NodeCnt)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%NodeIDs)) THEN
   DEALLOCATE(meshauxdatatypeData%NodeIDs)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%ElmIDs)) THEN
   DEALLOCATE(meshauxdatatypeData%ElmIDs)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%ElmNds)) THEN
   DEALLOCATE(meshauxdatatypeData%ElmNds)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%Me)) THEN
   DEALLOCATE(meshauxdatatypeData%Me)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%Ke)) THEN
   DEALLOCATE(meshauxdatatypeData%Ke)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%Fg)) THEN
   DEALLOCATE(meshauxdatatypeData%Fg)
ENDIF
 END SUBROUTINE SD_Destroymeshauxdatatype

 SUBROUTINE SD_Packmeshauxdatatype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(meshauxdatatype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MemberID
  Int_BufSz  = Int_BufSz  + 1  ! NOutCnt
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodeCnt )  ! NodeCnt 
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodeIDs )  ! NodeIDs 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmIDs )  ! ElmIDs 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNds )  ! ElmNds 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmID2s )  ! ElmID2s 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNd2s )  ! ElmNd2s 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Me )  ! Me 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ke )  ! Ke 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fg )  ! Fg 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Me2 )  ! Me2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ke2 )  ! Ke2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fg2 )  ! Fg2 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NOutCnt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NodeCnt) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeCnt))-1 ) = PACK(InData%NodeCnt ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(InData%NodeIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeIDs))-1 ) = PACK(InData%NodeIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmIDs))-1 ) = PACK(InData%ElmIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmNds) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNds))-1 ) = PACK(InData%ElmNds ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNds)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmID2s))-1 ) = PACK(InData%ElmID2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmID2s)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNd2s))-1 ) = PACK(InData%ElmNd2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNd2s)
  IF ( ALLOCATED(InData%Me) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me))-1 ) =  PACK(InData%Me ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Me)
  ENDIF
  IF ( ALLOCATED(InData%Ke) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke))-1 ) =  PACK(InData%Ke ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Ke)
  ENDIF
  IF ( ALLOCATED(InData%Fg) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg))-1 ) =  PACK(InData%Fg ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fg)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me2))-1 ) =  PACK(InData%Me2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Me2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke2))-1 ) =  PACK(InData%Ke2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Ke2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg2))-1 ) =  PACK(InData%Fg2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Fg2)
 END SUBROUTINE SD_Packmeshauxdatatype

 SUBROUTINE SD_UnPackmeshauxdatatype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(meshauxdatatype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MemberID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NOutCnt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NodeCnt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeCnt,1))); mask1 = .TRUE.
    OutData%NodeCnt = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeCnt))-1 ),mask1,OutData%NodeCnt)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(OutData%NodeIDs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeIDs,1))); mask1 = .TRUE.
    OutData%NodeIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeIDs))-1 ),mask1,OutData%NodeIDs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmIDs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmIDs,1),SIZE(OutData%ElmIDs,2))); mask2 = .TRUE.
    OutData%ElmIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmIDs))-1 ),mask2,OutData%ElmIDs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmNds) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmNds,1),SIZE(OutData%ElmNds,2))); mask2 = .TRUE.
    OutData%ElmNds = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNds))-1 ),mask2,OutData%ElmNds)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNds)
  ENDIF
  ALLOCATE(mask1(SIZE(OutData%ElmID2s,1))); mask1 = .TRUE.
  OutData%ElmID2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmID2s))-1 ),mask1,OutData%ElmID2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmID2s)
  ALLOCATE(mask1(SIZE(OutData%ElmNd2s,1))); mask1 = .TRUE.
  OutData%ElmNd2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNd2s))-1 ),mask1,OutData%ElmNd2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNd2s)
  IF ( ALLOCATED(OutData%Me) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Me,1),SIZE(OutData%Me,2),SIZE(OutData%Me,3),SIZE(OutData%Me,4))); mask4 = .TRUE.
    OutData%Me = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me))-1 ),mask4,OutData%Me)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Me)
  ENDIF
  IF ( ALLOCATED(OutData%Ke) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Ke,1),SIZE(OutData%Ke,2),SIZE(OutData%Ke,3),SIZE(OutData%Ke,4))); mask4 = .TRUE.
    OutData%Ke = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke))-1 ),mask4,OutData%Ke)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke)
  ENDIF
  IF ( ALLOCATED(OutData%Fg) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Fg,1),SIZE(OutData%Fg,2),SIZE(OutData%Fg,3))); mask3 = .TRUE.
    OutData%Fg = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg))-1 ),mask3,OutData%Fg)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg)
  ENDIF
  ALLOCATE(mask3(SIZE(OutData%Me2,1),SIZE(OutData%Me2,2),SIZE(OutData%Me2,3))); mask3 = .TRUE.
  OutData%Me2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me2))-1 ),mask3,OutData%Me2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Me2)
  ALLOCATE(mask3(SIZE(OutData%Ke2,1),SIZE(OutData%Ke2,2),SIZE(OutData%Ke2,3))); mask3 = .TRUE.
  OutData%Ke2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke2))-1 ),mask3,OutData%Ke2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke2)
  ALLOCATE(mask2(SIZE(OutData%Fg2,1),SIZE(OutData%Fg2,2))); mask2 = .TRUE.
  OutData%Fg2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg2))-1 ),mask2,OutData%Fg2)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg2)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackmeshauxdatatype

 SUBROUTINE SD_Copyelemproptype( SrcelemproptypeData, DstelemproptypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(elemproptype), INTENT(INOUT) :: SrcelemproptypeData
   TYPE(elemproptype), INTENT(INOUT) :: DstelemproptypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstelemproptypeData%Area = SrcelemproptypeData%Area
   DstelemproptypeData%Length = SrcelemproptypeData%Length
   DstelemproptypeData%Ixx = SrcelemproptypeData%Ixx
   DstelemproptypeData%Iyy = SrcelemproptypeData%Iyy
   DstelemproptypeData%Jzz = SrcelemproptypeData%Jzz
   DstelemproptypeData%Shear = SrcelemproptypeData%Shear
   DstelemproptypeData%Kappa = SrcelemproptypeData%Kappa
   DstelemproptypeData%YoungE = SrcelemproptypeData%YoungE
   DstelemproptypeData%ShearG = SrcelemproptypeData%ShearG
   DstelemproptypeData%Rho = SrcelemproptypeData%Rho
   DstelemproptypeData%DirCos = SrcelemproptypeData%DirCos
 END SUBROUTINE SD_Copyelemproptype

 SUBROUTINE SD_Destroyelemproptype( elemproptypeData, ErrStat, ErrMsg )
  TYPE(elemproptype), INTENT(INOUT) :: elemproptypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_Destroyelemproptype

 SUBROUTINE SD_Packelemproptype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(elemproptype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Area
  Re_BufSz   = Re_BufSz   + 1  ! Length
  Re_BufSz   = Re_BufSz   + 1  ! Ixx
  Re_BufSz   = Re_BufSz   + 1  ! Iyy
  Re_BufSz   = Re_BufSz   + 1  ! Jzz
  Re_BufSz   = Re_BufSz   + 1  ! Kappa
  Re_BufSz   = Re_BufSz   + 1  ! YoungE
  Re_BufSz   = Re_BufSz   + 1  ! ShearG
  Re_BufSz   = Re_BufSz   + 1  ! Rho
  Re_BufSz    = Re_BufSz    + SIZE( InData%DirCos )  ! DirCos 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Area )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Length )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ixx )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Iyy )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Jzz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Kappa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YoungE )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ShearG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Rho )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DirCos))-1 ) =  PACK(InData%DirCos ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DirCos)
 END SUBROUTINE SD_Packelemproptype

 SUBROUTINE SD_UnPackelemproptype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(elemproptype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Area = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Length = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ixx = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Iyy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Jzz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Kappa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YoungE = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ShearG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Rho = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%DirCos,1),SIZE(OutData%DirCos,2))); mask2 = .TRUE.
  OutData%DirCos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DirCos))-1 ),mask2,OutData%DirCos)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DirCos)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackelemproptype

 SUBROUTINE SD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(SD_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%SDInputFile = SrcInitInputData%SDInputFile
   DstInitInputData%g = SrcInitInputData%g
   DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
   DstInitInputData%TP_RefPoint = SrcInitInputData%TP_RefPoint
   DstInitInputData%SubRotateZ = SrcInitInputData%SubRotateZ
   DstInitInputData%SubDynSum = SrcInitInputData%SubDynSum
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%DT = SrcInitInputData%DT
   DstInitInputData%ErrStat = SrcInitInputData%ErrStat
   DstInitInputData%NJoints = SrcInitInputData%NJoints
   DstInitInputData%JointsCol = SrcInitInputData%JointsCol
   DstInitInputData%MembersCol = SrcInitInputData%MembersCol
   DstInitInputData%NPropSets = SrcInitInputData%NPropSets
   DstInitInputData%PropSetsCol = SrcInitInputData%PropSetsCol
   DstInitInputData%NXPropSets = SrcInitInputData%NXPropSets
   DstInitInputData%XPropSetsCol = SrcInitInputData%XPropSetsCol
   DstInitInputData%ReactCol = SrcInitInputData%ReactCol
   DstInitInputData%NInterf = SrcInitInputData%NInterf
   DstInitInputData%InterfCol = SrcInitInputData%InterfCol
   DstInitInputData%NCMass = SrcInitInputData%NCMass
   DstInitInputData%CMassCol = SrcInitInputData%CMassCol
   DstInitInputData%NCOSMs = SrcInitInputData%NCOSMs
   DstInitInputData%COSMsCol = SrcInitInputData%COSMsCol
   DstInitInputData%FEMMod = SrcInitInputData%FEMMod
   DstInitInputData%NDiv = SrcInitInputData%NDiv
   DstInitInputData%CBMod = SrcInitInputData%CBMod
IF (ALLOCATED(SrcInitInputData%Joints)) THEN
   i1_l = LBOUND(SrcInitInputData%Joints,1)
   i1_u = UBOUND(SrcInitInputData%Joints,1)
   i2_l = LBOUND(SrcInitInputData%Joints,2)
   i2_u = UBOUND(SrcInitInputData%Joints,2)
   IF (.NOT.ALLOCATED(DstInitInputData%Joints)) THEN 
      ALLOCATE(DstInitInputData%Joints(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%Joints.'
         RETURN
      END IF
   END IF
   DstInitInputData%Joints = SrcInitInputData%Joints
ENDIF
IF (ALLOCATED(SrcInitInputData%PropSets)) THEN
   i1_l = LBOUND(SrcInitInputData%PropSets,1)
   i1_u = UBOUND(SrcInitInputData%PropSets,1)
   i2_l = LBOUND(SrcInitInputData%PropSets,2)
   i2_u = UBOUND(SrcInitInputData%PropSets,2)
   IF (.NOT.ALLOCATED(DstInitInputData%PropSets)) THEN 
      ALLOCATE(DstInitInputData%PropSets(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%PropSets.'
         RETURN
      END IF
   END IF
   DstInitInputData%PropSets = SrcInitInputData%PropSets
ENDIF
IF (ALLOCATED(SrcInitInputData%XPropSets)) THEN
   i1_l = LBOUND(SrcInitInputData%XPropSets,1)
   i1_u = UBOUND(SrcInitInputData%XPropSets,1)
   i2_l = LBOUND(SrcInitInputData%XPropSets,2)
   i2_u = UBOUND(SrcInitInputData%XPropSets,2)
   IF (.NOT.ALLOCATED(DstInitInputData%XPropSets)) THEN 
      ALLOCATE(DstInitInputData%XPropSets(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%XPropSets.'
         RETURN
      END IF
   END IF
   DstInitInputData%XPropSets = SrcInitInputData%XPropSets
ENDIF
IF (ALLOCATED(SrcInitInputData%COSMs)) THEN
   i1_l = LBOUND(SrcInitInputData%COSMs,1)
   i1_u = UBOUND(SrcInitInputData%COSMs,1)
   i2_l = LBOUND(SrcInitInputData%COSMs,2)
   i2_u = UBOUND(SrcInitInputData%COSMs,2)
   IF (.NOT.ALLOCATED(DstInitInputData%COSMs)) THEN 
      ALLOCATE(DstInitInputData%COSMs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%COSMs.'
         RETURN
      END IF
   END IF
   DstInitInputData%COSMs = SrcInitInputData%COSMs
ENDIF
IF (ALLOCATED(SrcInitInputData%CMass)) THEN
   i1_l = LBOUND(SrcInitInputData%CMass,1)
   i1_u = UBOUND(SrcInitInputData%CMass,1)
   i2_l = LBOUND(SrcInitInputData%CMass,2)
   i2_u = UBOUND(SrcInitInputData%CMass,2)
   IF (.NOT.ALLOCATED(DstInitInputData%CMass)) THEN 
      ALLOCATE(DstInitInputData%CMass(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%CMass.'
         RETURN
      END IF
   END IF
   DstInitInputData%CMass = SrcInitInputData%CMass
ENDIF
IF (ALLOCATED(SrcInitInputData%JDampings)) THEN
   i1_l = LBOUND(SrcInitInputData%JDampings,1)
   i1_u = UBOUND(SrcInitInputData%JDampings,1)
   IF (.NOT.ALLOCATED(DstInitInputData%JDampings)) THEN 
      ALLOCATE(DstInitInputData%JDampings(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%JDampings.'
         RETURN
      END IF
   END IF
   DstInitInputData%JDampings = SrcInitInputData%JDampings
ENDIF
IF (ALLOCATED(SrcInitInputData%Members)) THEN
   i1_l = LBOUND(SrcInitInputData%Members,1)
   i1_u = UBOUND(SrcInitInputData%Members,1)
   i2_l = LBOUND(SrcInitInputData%Members,2)
   i2_u = UBOUND(SrcInitInputData%Members,2)
   IF (.NOT.ALLOCATED(DstInitInputData%Members)) THEN 
      ALLOCATE(DstInitInputData%Members(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%Members.'
         RETURN
      END IF
   END IF
   DstInitInputData%Members = SrcInitInputData%Members
ENDIF
IF (ALLOCATED(SrcInitInputData%Interf)) THEN
   i1_l = LBOUND(SrcInitInputData%Interf,1)
   i1_u = UBOUND(SrcInitInputData%Interf,1)
   i2_l = LBOUND(SrcInitInputData%Interf,2)
   i2_u = UBOUND(SrcInitInputData%Interf,2)
   IF (.NOT.ALLOCATED(DstInitInputData%Interf)) THEN 
      ALLOCATE(DstInitInputData%Interf(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%Interf.'
         RETURN
      END IF
   END IF
   DstInitInputData%Interf = SrcInitInputData%Interf
ENDIF
   DstInitInputData%NNode = SrcInitInputData%NNode
   DstInitInputData%NElem = SrcInitInputData%NElem
   DstInitInputData%NProp = SrcInitInputData%NProp
   DstInitInputData%TDOF = SrcInitInputData%TDOF
   DstInitInputData%MaxMemJnt = SrcInitInputData%MaxMemJnt
IF (ALLOCATED(SrcInitInputData%Nodes)) THEN
   i1_l = LBOUND(SrcInitInputData%Nodes,1)
   i1_u = UBOUND(SrcInitInputData%Nodes,1)
   i2_l = LBOUND(SrcInitInputData%Nodes,2)
   i2_u = UBOUND(SrcInitInputData%Nodes,2)
   IF (.NOT.ALLOCATED(DstInitInputData%Nodes)) THEN 
      ALLOCATE(DstInitInputData%Nodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%Nodes.'
         RETURN
      END IF
   END IF
   DstInitInputData%Nodes = SrcInitInputData%Nodes
ENDIF
IF (ALLOCATED(SrcInitInputData%Props)) THEN
   i1_l = LBOUND(SrcInitInputData%Props,1)
   i1_u = UBOUND(SrcInitInputData%Props,1)
   i2_l = LBOUND(SrcInitInputData%Props,2)
   i2_u = UBOUND(SrcInitInputData%Props,2)
   IF (.NOT.ALLOCATED(DstInitInputData%Props)) THEN 
      ALLOCATE(DstInitInputData%Props(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%Props.'
         RETURN
      END IF
   END IF
   DstInitInputData%Props = SrcInitInputData%Props
ENDIF
IF (ALLOCATED(SrcInitInputData%K)) THEN
   i1_l = LBOUND(SrcInitInputData%K,1)
   i1_u = UBOUND(SrcInitInputData%K,1)
   i2_l = LBOUND(SrcInitInputData%K,2)
   i2_u = UBOUND(SrcInitInputData%K,2)
   IF (.NOT.ALLOCATED(DstInitInputData%K)) THEN 
      ALLOCATE(DstInitInputData%K(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%K.'
         RETURN
      END IF
   END IF
   DstInitInputData%K = SrcInitInputData%K
ENDIF
IF (ALLOCATED(SrcInitInputData%M)) THEN
   i1_l = LBOUND(SrcInitInputData%M,1)
   i1_u = UBOUND(SrcInitInputData%M,1)
   i2_l = LBOUND(SrcInitInputData%M,2)
   i2_u = UBOUND(SrcInitInputData%M,2)
   IF (.NOT.ALLOCATED(DstInitInputData%M)) THEN 
      ALLOCATE(DstInitInputData%M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%M.'
         RETURN
      END IF
   END IF
   DstInitInputData%M = SrcInitInputData%M
ENDIF
IF (ALLOCATED(SrcInitInputData%F)) THEN
   i1_l = LBOUND(SrcInitInputData%F,1)
   i1_u = UBOUND(SrcInitInputData%F,1)
   IF (.NOT.ALLOCATED(DstInitInputData%F)) THEN 
      ALLOCATE(DstInitInputData%F(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%F.'
         RETURN
      END IF
   END IF
   DstInitInputData%F = SrcInitInputData%F
ENDIF
IF (ALLOCATED(SrcInitInputData%FG)) THEN
   i1_l = LBOUND(SrcInitInputData%FG,1)
   i1_u = UBOUND(SrcInitInputData%FG,1)
   IF (.NOT.ALLOCATED(DstInitInputData%FG)) THEN 
      ALLOCATE(DstInitInputData%FG(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%FG.'
         RETURN
      END IF
   END IF
   DstInitInputData%FG = SrcInitInputData%FG
ENDIF
IF (ALLOCATED(SrcInitInputData%ElemProps)) THEN
   i1_l = LBOUND(SrcInitInputData%ElemProps,1)
   i1_u = UBOUND(SrcInitInputData%ElemProps,1)
   i2_l = LBOUND(SrcInitInputData%ElemProps,2)
   i2_u = UBOUND(SrcInitInputData%ElemProps,2)
   IF (.NOT.ALLOCATED(DstInitInputData%ElemProps)) THEN 
      ALLOCATE(DstInitInputData%ElemProps(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%ElemProps.'
         RETURN
      END IF
   END IF
   DstInitInputData%ElemProps = SrcInitInputData%ElemProps
ENDIF
IF (ALLOCATED(SrcInitInputData%BCs)) THEN
   i1_l = LBOUND(SrcInitInputData%BCs,1)
   i1_u = UBOUND(SrcInitInputData%BCs,1)
   i2_l = LBOUND(SrcInitInputData%BCs,2)
   i2_u = UBOUND(SrcInitInputData%BCs,2)
   IF (.NOT.ALLOCATED(DstInitInputData%BCs)) THEN 
      ALLOCATE(DstInitInputData%BCs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%BCs.'
         RETURN
      END IF
   END IF
   DstInitInputData%BCs = SrcInitInputData%BCs
ENDIF
IF (ALLOCATED(SrcInitInputData%IntFc)) THEN
   i1_l = LBOUND(SrcInitInputData%IntFc,1)
   i1_u = UBOUND(SrcInitInputData%IntFc,1)
   i2_l = LBOUND(SrcInitInputData%IntFc,2)
   i2_u = UBOUND(SrcInitInputData%IntFc,2)
   IF (.NOT.ALLOCATED(DstInitInputData%IntFc)) THEN 
      ALLOCATE(DstInitInputData%IntFc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%IntFc.'
         RETURN
      END IF
   END IF
   DstInitInputData%IntFc = SrcInitInputData%IntFc
ENDIF
IF (ALLOCATED(SrcInitInputData%MemberNodes)) THEN
   i1_l = LBOUND(SrcInitInputData%MemberNodes,1)
   i1_u = UBOUND(SrcInitInputData%MemberNodes,1)
   i2_l = LBOUND(SrcInitInputData%MemberNodes,2)
   i2_u = UBOUND(SrcInitInputData%MemberNodes,2)
   IF (.NOT.ALLOCATED(DstInitInputData%MemberNodes)) THEN 
      ALLOCATE(DstInitInputData%MemberNodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%MemberNodes.'
         RETURN
      END IF
   END IF
   DstInitInputData%MemberNodes = SrcInitInputData%MemberNodes
ENDIF
IF (ALLOCATED(SrcInitInputData%NodesConnN)) THEN
   i1_l = LBOUND(SrcInitInputData%NodesConnN,1)
   i1_u = UBOUND(SrcInitInputData%NodesConnN,1)
   i2_l = LBOUND(SrcInitInputData%NodesConnN,2)
   i2_u = UBOUND(SrcInitInputData%NodesConnN,2)
   IF (.NOT.ALLOCATED(DstInitInputData%NodesConnN)) THEN 
      ALLOCATE(DstInitInputData%NodesConnN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%NodesConnN.'
         RETURN
      END IF
   END IF
   DstInitInputData%NodesConnN = SrcInitInputData%NodesConnN
ENDIF
IF (ALLOCATED(SrcInitInputData%NodesConnE)) THEN
   i1_l = LBOUND(SrcInitInputData%NodesConnE,1)
   i1_u = UBOUND(SrcInitInputData%NodesConnE,1)
   i2_l = LBOUND(SrcInitInputData%NodesConnE,2)
   i2_u = UBOUND(SrcInitInputData%NodesConnE,2)
   IF (.NOT.ALLOCATED(DstInitInputData%NodesConnE)) THEN 
      ALLOCATE(DstInitInputData%NodesConnE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitInput: Error allocating DstInitInputData%NodesConnE.'
         RETURN
      END IF
   END IF
   DstInitInputData%NodesConnE = SrcInitInputData%NodesConnE
ENDIF
   DstInitInputData%SSSum = SrcInitInputData%SSSum
   DstInitInputData%UnSum = SrcInitInputData%UnSum
 END SUBROUTINE SD_CopyInitInput

 SUBROUTINE SD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SD_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%Joints)) THEN
   DEALLOCATE(InitInputData%Joints)
ENDIF
IF (ALLOCATED(InitInputData%PropSets)) THEN
   DEALLOCATE(InitInputData%PropSets)
ENDIF
IF (ALLOCATED(InitInputData%XPropSets)) THEN
   DEALLOCATE(InitInputData%XPropSets)
ENDIF
IF (ALLOCATED(InitInputData%COSMs)) THEN
   DEALLOCATE(InitInputData%COSMs)
ENDIF
IF (ALLOCATED(InitInputData%CMass)) THEN
   DEALLOCATE(InitInputData%CMass)
ENDIF
IF (ALLOCATED(InitInputData%JDampings)) THEN
   DEALLOCATE(InitInputData%JDampings)
ENDIF
IF (ALLOCATED(InitInputData%Members)) THEN
   DEALLOCATE(InitInputData%Members)
ENDIF
IF (ALLOCATED(InitInputData%Interf)) THEN
   DEALLOCATE(InitInputData%Interf)
ENDIF
IF (ALLOCATED(InitInputData%Nodes)) THEN
   DEALLOCATE(InitInputData%Nodes)
ENDIF
IF (ALLOCATED(InitInputData%Props)) THEN
   DEALLOCATE(InitInputData%Props)
ENDIF
IF (ALLOCATED(InitInputData%K)) THEN
   DEALLOCATE(InitInputData%K)
ENDIF
IF (ALLOCATED(InitInputData%M)) THEN
   DEALLOCATE(InitInputData%M)
ENDIF
IF (ALLOCATED(InitInputData%F)) THEN
   DEALLOCATE(InitInputData%F)
ENDIF
IF (ALLOCATED(InitInputData%FG)) THEN
   DEALLOCATE(InitInputData%FG)
ENDIF
IF (ALLOCATED(InitInputData%ElemProps)) THEN
   DEALLOCATE(InitInputData%ElemProps)
ENDIF
IF (ALLOCATED(InitInputData%BCs)) THEN
   DEALLOCATE(InitInputData%BCs)
ENDIF
IF (ALLOCATED(InitInputData%IntFc)) THEN
   DEALLOCATE(InitInputData%IntFc)
ENDIF
IF (ALLOCATED(InitInputData%MemberNodes)) THEN
   DEALLOCATE(InitInputData%MemberNodes)
ENDIF
IF (ALLOCATED(InitInputData%NodesConnN)) THEN
   DEALLOCATE(InitInputData%NodesConnN)
ENDIF
IF (ALLOCATED(InitInputData%NodesConnE)) THEN
   DEALLOCATE(InitInputData%NodesConnE)
ENDIF
 END SUBROUTINE SD_DestroyInitInput

 SUBROUTINE SD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
  Re_BufSz    = Re_BufSz    + SIZE( InData%TP_RefPoint )  ! TP_RefPoint 
  Re_BufSz   = Re_BufSz   + 1  ! SubRotateZ
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz  = Int_BufSz  + 1  ! ErrStat
  Int_BufSz  = Int_BufSz  + 1  ! NJoints
  Int_BufSz  = Int_BufSz  + 1  ! JointsCol
  Int_BufSz  = Int_BufSz  + 1  ! MembersCol
  Int_BufSz  = Int_BufSz  + 1  ! NPropSets
  Int_BufSz  = Int_BufSz  + 1  ! PropSetsCol
  Int_BufSz  = Int_BufSz  + 1  ! NXPropSets
  Int_BufSz  = Int_BufSz  + 1  ! XPropSetsCol
  Int_BufSz  = Int_BufSz  + 1  ! ReactCol
  Int_BufSz  = Int_BufSz  + 1  ! NInterf
  Int_BufSz  = Int_BufSz  + 1  ! InterfCol
  Int_BufSz  = Int_BufSz  + 1  ! NCMass
  Int_BufSz  = Int_BufSz  + 1  ! CMassCol
  Int_BufSz  = Int_BufSz  + 1  ! NCOSMs
  Int_BufSz  = Int_BufSz  + 1  ! COSMsCol
  Int_BufSz  = Int_BufSz  + 1  ! FEMMod
  Int_BufSz  = Int_BufSz  + 1  ! NDiv
  Re_BufSz    = Re_BufSz    + SIZE( InData%Joints )  ! Joints 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PropSets )  ! PropSets 
  Re_BufSz    = Re_BufSz    + SIZE( InData%XPropSets )  ! XPropSets 
  Re_BufSz    = Re_BufSz    + SIZE( InData%COSMs )  ! COSMs 
  Re_BufSz    = Re_BufSz    + SIZE( InData%CMass )  ! CMass 
  Re_BufSz    = Re_BufSz    + SIZE( InData%JDampings )  ! JDampings 
  Int_BufSz   = Int_BufSz   + SIZE( InData%Members )  ! Members 
  Int_BufSz   = Int_BufSz   + SIZE( InData%Interf )  ! Interf 
  Int_BufSz  = Int_BufSz  + 1  ! NNode
  Int_BufSz  = Int_BufSz  + 1  ! NElem
  Int_BufSz  = Int_BufSz  + 1  ! NProp
  Int_BufSz  = Int_BufSz  + 1  ! TDOF
  Int_BufSz  = Int_BufSz  + 1  ! MaxMemJnt
  Re_BufSz    = Re_BufSz    + SIZE( InData%Nodes )  ! Nodes 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Props )  ! Props 
  Re_BufSz    = Re_BufSz    + SIZE( InData%K )  ! K 
  Re_BufSz    = Re_BufSz    + SIZE( InData%M )  ! M 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FG )  ! FG 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ElemProps )  ! ElemProps 
  Int_BufSz   = Int_BufSz   + SIZE( InData%BCs )  ! BCs 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IntFc )  ! IntFc 
  Int_BufSz   = Int_BufSz   + SIZE( InData%MemberNodes )  ! MemberNodes 
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnN )  ! NodesConnN 
  Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnE )  ! NodesConnE 
  Int_BufSz  = Int_BufSz  + 1  ! UnSum
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TP_RefPoint))-1 ) =  PACK(InData%TP_RefPoint ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TP_RefPoint)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SubRotateZ )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ErrStat )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NJoints )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MembersCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%PropSetsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NXPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%XPropSetsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ReactCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NInterf )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InterfCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCMass )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%CMassCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCOSMs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%COSMsCol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%FEMMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDiv )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Joints) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Joints))-1 ) =  PACK(InData%Joints ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Joints)
  ENDIF
  IF ( ALLOCATED(InData%PropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PropSets))-1 ) =  PACK(InData%PropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PropSets)
  ENDIF
  IF ( ALLOCATED(InData%XPropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%XPropSets))-1 ) =  PACK(InData%XPropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%XPropSets)
  ENDIF
  IF ( ALLOCATED(InData%COSMs) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%COSMs))-1 ) =  PACK(InData%COSMs ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%COSMs)
  ENDIF
  IF ( ALLOCATED(InData%CMass) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CMass))-1 ) =  PACK(InData%CMass ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CMass)
  ENDIF
  IF ( ALLOCATED(InData%JDampings) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%JDampings))-1 ) =  PACK(InData%JDampings ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%JDampings)
  ENDIF
  IF ( ALLOCATED(InData%Members) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Members))-1 ) = PACK(InData%Members ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Members)
  ENDIF
  IF ( ALLOCATED(InData%Interf) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Interf))-1 ) = PACK(InData%Interf ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Interf)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NElem )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NProp )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TDOF )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxMemJnt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Nodes) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Nodes))-1 ) =  PACK(InData%Nodes ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Nodes)
  ENDIF
  IF ( ALLOCATED(InData%Props) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Props))-1 ) =  PACK(InData%Props ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Props)
  ENDIF
  IF ( ALLOCATED(InData%K) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%K))-1 ) =  PACK(InData%K ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%K)
  ENDIF
  IF ( ALLOCATED(InData%M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%M))-1 ) =  PACK(InData%M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%M)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
  IF ( ALLOCATED(InData%FG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FG))-1 ) =  PACK(InData%FG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FG)
  ENDIF
  IF ( ALLOCATED(InData%ElemProps) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ElemProps))-1 ) =  PACK(InData%ElemProps ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ElemProps)
  ENDIF
  IF ( ALLOCATED(InData%BCs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%BCs))-1 ) = PACK(InData%BCs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%BCs)
  ENDIF
  IF ( ALLOCATED(InData%IntFc) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IntFc))-1 ) = PACK(InData%IntFc ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IntFc)
  ENDIF
  IF ( ALLOCATED(InData%MemberNodes) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MemberNodes))-1 ) = PACK(InData%MemberNodes ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnN) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnN))-1 ) = PACK(InData%NodesConnN ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnE) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnE))-1 ) = PACK(InData%NodesConnE ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnE)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnSum )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackInitInput

 SUBROUTINE SD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%TP_RefPoint,1))); mask1 = .TRUE.
  OutData%TP_RefPoint = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TP_RefPoint))-1 ),mask1,OutData%TP_RefPoint)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TP_RefPoint)
  OutData%SubRotateZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%ErrStat = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NJoints = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%JointsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MembersCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%PropSetsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NXPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%XPropSetsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ReactCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NInterf = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InterfCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCMass = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%CMassCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCOSMs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%COSMsCol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%FEMMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NDiv = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Joints) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Joints,1),SIZE(OutData%Joints,2))); mask2 = .TRUE.
    OutData%Joints = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Joints))-1 ),mask2,OutData%Joints)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Joints)
  ENDIF
  IF ( ALLOCATED(OutData%PropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PropSets,1),SIZE(OutData%PropSets,2))); mask2 = .TRUE.
    OutData%PropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PropSets))-1 ),mask2,OutData%PropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PropSets)
  ENDIF
  IF ( ALLOCATED(OutData%XPropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%XPropSets,1),SIZE(OutData%XPropSets,2))); mask2 = .TRUE.
    OutData%XPropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%XPropSets))-1 ),mask2,OutData%XPropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%XPropSets)
  ENDIF
  IF ( ALLOCATED(OutData%COSMs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%COSMs,1),SIZE(OutData%COSMs,2))); mask2 = .TRUE.
    OutData%COSMs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%COSMs))-1 ),mask2,OutData%COSMs)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%COSMs)
  ENDIF
  IF ( ALLOCATED(OutData%CMass) ) THEN
  ALLOCATE(mask2(SIZE(OutData%CMass,1),SIZE(OutData%CMass,2))); mask2 = .TRUE.
    OutData%CMass = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CMass))-1 ),mask2,OutData%CMass)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CMass)
  ENDIF
  IF ( ALLOCATED(OutData%JDampings) ) THEN
  ALLOCATE(mask1(SIZE(OutData%JDampings,1))); mask1 = .TRUE.
    OutData%JDampings = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%JDampings))-1 ),mask1,OutData%JDampings)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%JDampings)
  ENDIF
  IF ( ALLOCATED(OutData%Members) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Members,1),SIZE(OutData%Members,2))); mask2 = .TRUE.
    OutData%Members = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Members))-1 ),mask2,OutData%Members)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Members)
  ENDIF
  IF ( ALLOCATED(OutData%Interf) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Interf,1),SIZE(OutData%Interf,2))); mask2 = .TRUE.
    OutData%Interf = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Interf))-1 ),mask2,OutData%Interf)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Interf)
  ENDIF
  OutData%NNode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NElem = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NProp = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TDOF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MaxMemJnt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Nodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Nodes,1),SIZE(OutData%Nodes,2))); mask2 = .TRUE.
    OutData%Nodes = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Nodes))-1 ),mask2,OutData%Nodes)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Nodes)
  ENDIF
  IF ( ALLOCATED(OutData%Props) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Props,1),SIZE(OutData%Props,2))); mask2 = .TRUE.
    OutData%Props = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Props))-1 ),mask2,OutData%Props)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Props)
  ENDIF
  IF ( ALLOCATED(OutData%K) ) THEN
  ALLOCATE(mask2(SIZE(OutData%K,1),SIZE(OutData%K,2))); mask2 = .TRUE.
    OutData%K = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%K))-1 ),mask2,OutData%K)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%K)
  ENDIF
  IF ( ALLOCATED(OutData%M) ) THEN
  ALLOCATE(mask2(SIZE(OutData%M,1),SIZE(OutData%M,2))); mask2 = .TRUE.
    OutData%M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%M))-1 ),mask2,OutData%M)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%M)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F,1))); mask1 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask1,OutData%F)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  IF ( ALLOCATED(OutData%FG) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FG,1))); mask1 = .TRUE.
    OutData%FG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FG))-1 ),mask1,OutData%FG)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FG)
  ENDIF
  IF ( ALLOCATED(OutData%ElemProps) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElemProps,1),SIZE(OutData%ElemProps,2))); mask2 = .TRUE.
    OutData%ElemProps = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ElemProps))-1 ),mask2,OutData%ElemProps)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ElemProps)
  ENDIF
  IF ( ALLOCATED(OutData%BCs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%BCs,1),SIZE(OutData%BCs,2))); mask2 = .TRUE.
    OutData%BCs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%BCs))-1 ),mask2,OutData%BCs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%BCs)
  ENDIF
  IF ( ALLOCATED(OutData%IntFc) ) THEN
  ALLOCATE(mask2(SIZE(OutData%IntFc,1),SIZE(OutData%IntFc,2))); mask2 = .TRUE.
    OutData%IntFc = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IntFc))-1 ),mask2,OutData%IntFc)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IntFc)
  ENDIF
  IF ( ALLOCATED(OutData%MemberNodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MemberNodes,1),SIZE(OutData%MemberNodes,2))); mask2 = .TRUE.
    OutData%MemberNodes = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%MemberNodes))-1 ),mask2,OutData%MemberNodes)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnN) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnN,1),SIZE(OutData%NodesConnN,2))); mask2 = .TRUE.
    OutData%NodesConnN = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnN))-1 ),mask2,OutData%NodesConnN)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnE) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnE,1),SIZE(OutData%NodesConnE,2))); mask2 = .TRUE.
    OutData%NodesConnE = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnE))-1 ),mask2,OutData%NodesConnE)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnE)
  ENDIF
  OutData%UnSum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInitInput

 SUBROUTINE SD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(SD_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitOutput: Error allocating DstInitOutputData%WriteOutputHdr.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitOutput: Error allocating DstInitOutputData%WriteOutputUnt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat, ErrMsg )
   DstInitOutputData%MaxOutChs = SrcInitOutputData%MaxOutChs
   DstInitOutputData%TabDelim = SrcInitOutputData%TabDelim
   DstInitOutputData%OutCOSM = SrcInitOutputData%OutCOSM
IF (ALLOCATED(SrcInitOutputData%SSOutList)) THEN
   i1_l = LBOUND(SrcInitOutputData%SSOutList,1)
   i1_u = UBOUND(SrcInitOutputData%SSOutList,1)
   IF (.NOT.ALLOCATED(DstInitOutputData%SSOutList)) THEN 
      ALLOCATE(DstInitOutputData%SSOutList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyInitOutput: Error allocating DstInitOutputData%SSOutList.'
         RETURN
      END IF
   END IF
   DstInitOutputData%SSOutList = SrcInitOutputData%SSOutList
ENDIF
 END SUBROUTINE SD_CopyInitOutput

 SUBROUTINE SD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SD_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%SSOutList)) THEN
   DEALLOCATE(InitOutputData%SSOutList)
ENDIF
 END SUBROUTINE SD_DestroyInitOutput

 SUBROUTINE SD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  Int_BufSz  = Int_BufSz  + 1  ! MaxOutChs
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxOutChs )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackInitOutput

 SUBROUTINE SD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  OutData%MaxOutChs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInitOutput

 SUBROUTINE SD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(SD_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
IF (ALLOCATED(SrcContStateData%qm)) THEN
   i1_l = LBOUND(SrcContStateData%qm,1)
   i1_u = UBOUND(SrcContStateData%qm,1)
   IF (.NOT.ALLOCATED(DstContStateData%qm)) THEN 
      ALLOCATE(DstContStateData%qm(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyContState: Error allocating DstContStateData%qm.'
         RETURN
      END IF
   END IF
   DstContStateData%qm = SrcContStateData%qm
ENDIF
IF (ALLOCATED(SrcContStateData%qmdot)) THEN
   i1_l = LBOUND(SrcContStateData%qmdot,1)
   i1_u = UBOUND(SrcContStateData%qmdot,1)
   IF (.NOT.ALLOCATED(DstContStateData%qmdot)) THEN 
      ALLOCATE(DstContStateData%qmdot(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyContState: Error allocating DstContStateData%qmdot.'
         RETURN
      END IF
   END IF
   DstContStateData%qmdot = SrcContStateData%qmdot
ENDIF
IF (ALLOCATED(SrcContStateData%qmdotdot)) THEN
   i1_l = LBOUND(SrcContStateData%qmdotdot,1)
   i1_u = UBOUND(SrcContStateData%qmdotdot,1)
   IF (.NOT.ALLOCATED(DstContStateData%qmdotdot)) THEN 
      ALLOCATE(DstContStateData%qmdotdot(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyContState: Error allocating DstContStateData%qmdotdot.'
         RETURN
      END IF
   END IF
   DstContStateData%qmdotdot = SrcContStateData%qmdotdot
ENDIF
 END SUBROUTINE SD_CopyContState

 SUBROUTINE SD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%qm)) THEN
   DEALLOCATE(ContStateData%qm)
ENDIF
IF (ALLOCATED(ContStateData%qmdot)) THEN
   DEALLOCATE(ContStateData%qmdot)
ENDIF
IF (ALLOCATED(ContStateData%qmdotdot)) THEN
   DEALLOCATE(ContStateData%qmdotdot)
ENDIF
 END SUBROUTINE SD_DestroyContState

 SUBROUTINE SD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  Re_BufSz    = Re_BufSz    + SIZE( InData%qm )  ! qm 
  Re_BufSz    = Re_BufSz    + SIZE( InData%qmdot )  ! qmdot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%qmdotdot )  ! qmdotdot 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%qm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qm))-1 ) =  PACK(InData%qm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qm)
  ENDIF
  IF ( ALLOCATED(InData%qmdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdot))-1 ) =  PACK(InData%qmdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdot)
  ENDIF
  IF ( ALLOCATED(InData%qmdotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdotdot))-1 ) =  PACK(InData%qmdotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdotdot)
  ENDIF
 END SUBROUTINE SD_PackContState

 SUBROUTINE SD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%qm) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qm,1))); mask1 = .TRUE.
    OutData%qm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qm))-1 ),mask1,OutData%qm)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qm)
  ENDIF
  IF ( ALLOCATED(OutData%qmdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdot,1))); mask1 = .TRUE.
    OutData%qmdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdot))-1 ),mask1,OutData%qmdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdot)
  ENDIF
  IF ( ALLOCATED(OutData%qmdotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdotdot,1))); mask1 = .TRUE.
    OutData%qmdotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdotdot))-1 ),mask1,OutData%qmdotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdotdot)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackContState

 SUBROUTINE SD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(SD_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE SD_CopyDiscState

 SUBROUTINE SD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SD_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyDiscState

 SUBROUTINE SD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackDiscState

 SUBROUTINE SD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackDiscState

 SUBROUTINE SD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(SD_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE SD_CopyConstrState

 SUBROUTINE SD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyConstrState

 SUBROUTINE SD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackConstrState

 SUBROUTINE SD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackConstrState

 SUBROUTINE SD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(SD_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%xdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%xdot,1)
   i1_u = UBOUND(SrcOtherStateData%xdot,1)
   IF (.NOT.ALLOCATED(DstOtherStateData%xdot)) THEN 
      ALLOCATE(DstOtherStateData%xdot(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyOtherState: Error allocating DstOtherStateData%xdot.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%xdot,1), UBOUND(SrcOtherStateData%xdot,1)
      CALL SD_CopyContState( SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
   DstOtherStateData%n = SrcOtherStateData%n
IF (ALLOCATED(SrcOtherStateData%Udotdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%Udotdot,1)
   i1_u = UBOUND(SrcOtherStateData%Udotdot,1)
   IF (.NOT.ALLOCATED(DstOtherStateData%Udotdot)) THEN 
      ALLOCATE(DstOtherStateData%Udotdot(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyOtherState: Error allocating DstOtherStateData%Udotdot.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Udotdot = SrcOtherStateData%Udotdot
ENDIF
IF (ALLOCATED(SrcOtherStateData%Y2)) THEN
   i1_l = LBOUND(SrcOtherStateData%Y2,1)
   i1_u = UBOUND(SrcOtherStateData%Y2,1)
   IF (.NOT.ALLOCATED(DstOtherStateData%Y2)) THEN 
      ALLOCATE(DstOtherStateData%Y2(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyOtherState: Error allocating DstOtherStateData%Y2.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Y2 = SrcOtherStateData%Y2
ENDIF
 END SUBROUTINE SD_CopyOtherState

 SUBROUTINE SD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SD_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%xdot)) THEN
DO i1 = LBOUND(OtherStateData%xdot,1), UBOUND(OtherStateData%xdot,1)
  CALL SD_DestroyContState( OtherStateData%xdot(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%xdot)
ENDIF
IF (ALLOCATED(OtherStateData%Udotdot)) THEN
   DEALLOCATE(OtherStateData%Udotdot)
ENDIF
IF (ALLOCATED(OtherStateData%Y2)) THEN
   DEALLOCATE(OtherStateData%Y2)
ENDIF
 END SUBROUTINE SD_DestroyOtherState

 SUBROUTINE SD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_xdot_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Db_xdot_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Int_xdot_Buf))Int_BufSz = Int_BufSz + SIZE( Int_xdot_Buf ) ! xdot
  IF(ALLOCATED(Re_xdot_Buf))  DEALLOCATE(Re_xdot_Buf)
  IF(ALLOCATED(Db_xdot_Buf))  DEALLOCATE(Db_xdot_Buf)
  IF(ALLOCATED(Int_xdot_Buf)) DEALLOCATE(Int_xdot_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! n
  Re_BufSz    = Re_BufSz    + SIZE( InData%Udotdot )  ! Udotdot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Y2 )  ! Y2 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, OnlySize ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 ) = Re_xdot_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 ) = Db_xdot_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 ) = Int_xdot_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  IF( ALLOCATED(Re_xdot_Buf) )  DEALLOCATE(Re_xdot_Buf)
  IF( ALLOCATED(Db_xdot_Buf) )  DEALLOCATE(Db_xdot_Buf)
  IF( ALLOCATED(Int_xdot_Buf) ) DEALLOCATE(Int_xdot_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%n )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Udotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Udotdot))-1 ) =  PACK(InData%Udotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Udotdot)
  ENDIF
  IF ( ALLOCATED(InData%Y2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Y2))-1 ) =  PACK(InData%Y2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Y2)
  ENDIF
 END SUBROUTINE SD_PackOtherState

 SUBROUTINE SD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_xdot_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(OutData%xdot,1), UBOUND(OutData%xdot,1)
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    Re_xdot_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    Db_xdot_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    Int_xdot_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg ) ! xdot 
ENDDO
  OutData%n = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Udotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Udotdot,1))); mask1 = .TRUE.
    OutData%Udotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Udotdot))-1 ),mask1,OutData%Udotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Udotdot)
  ENDIF
  IF ( ALLOCATED(OutData%Y2) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Y2,1))); mask1 = .TRUE.
    OutData%Y2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Y2))-1 ),mask1,OutData%Y2)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Y2)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackOtherState

 SUBROUTINE SD_Copyoutvar_type( Srcoutvar_typeData, Dstoutvar_typeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_outvar_type), INTENT(INOUT) :: Srcoutvar_typeData
   TYPE(sd_outvar_type), INTENT(INOUT) :: Dstoutvar_typeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   Dstoutvar_typeData%Indx = Srcoutvar_typeData%Indx
   Dstoutvar_typeData%SignM = Srcoutvar_typeData%SignM
   Dstoutvar_typeData%Units = Srcoutvar_typeData%Units
   Dstoutvar_typeData%Name = Srcoutvar_typeData%Name
 END SUBROUTINE SD_Copyoutvar_type

 SUBROUTINE SD_Destroyoutvar_type( outvar_typeData, ErrStat, ErrMsg )
  TYPE(sd_outvar_type), INTENT(INOUT) :: outvar_typeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_Destroyoutvar_type

 SUBROUTINE SD_Packoutvar_type( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_outvar_type),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! Indx
  Int_BufSz  = Int_BufSz  + 1  ! SignM
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%SignM )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_Packoutvar_type

 SUBROUTINE SD_UnPackoutvar_type( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_outvar_type), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%SignM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackoutvar_type

 SUBROUTINE SD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(SD_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcParamData%A_21)) THEN
   i1_l = LBOUND(SrcParamData%A_21,1)
   i1_u = UBOUND(SrcParamData%A_21,1)
   i2_l = LBOUND(SrcParamData%A_21,2)
   i2_u = UBOUND(SrcParamData%A_21,2)
   IF (.NOT.ALLOCATED(DstParamData%A_21)) THEN 
      ALLOCATE(DstParamData%A_21(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%A_21.'
         RETURN
      END IF
   END IF
   DstParamData%A_21 = SrcParamData%A_21
ENDIF
IF (ALLOCATED(SrcParamData%A_22)) THEN
   i1_l = LBOUND(SrcParamData%A_22,1)
   i1_u = UBOUND(SrcParamData%A_22,1)
   i2_l = LBOUND(SrcParamData%A_22,2)
   i2_u = UBOUND(SrcParamData%A_22,2)
   IF (.NOT.ALLOCATED(DstParamData%A_22)) THEN 
      ALLOCATE(DstParamData%A_22(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%A_22.'
         RETURN
      END IF
   END IF
   DstParamData%A_22 = SrcParamData%A_22
ENDIF
IF (ALLOCATED(SrcParamData%B_23)) THEN
   i1_l = LBOUND(SrcParamData%B_23,1)
   i1_u = UBOUND(SrcParamData%B_23,1)
   i2_l = LBOUND(SrcParamData%B_23,2)
   i2_u = UBOUND(SrcParamData%B_23,2)
   IF (.NOT.ALLOCATED(DstParamData%B_23)) THEN 
      ALLOCATE(DstParamData%B_23(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%B_23.'
         RETURN
      END IF
   END IF
   DstParamData%B_23 = SrcParamData%B_23
ENDIF
IF (ALLOCATED(SrcParamData%B_24)) THEN
   i1_l = LBOUND(SrcParamData%B_24,1)
   i1_u = UBOUND(SrcParamData%B_24,1)
   i2_l = LBOUND(SrcParamData%B_24,2)
   i2_u = UBOUND(SrcParamData%B_24,2)
   IF (.NOT.ALLOCATED(DstParamData%B_24)) THEN 
      ALLOCATE(DstParamData%B_24(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%B_24.'
         RETURN
      END IF
   END IF
   DstParamData%B_24 = SrcParamData%B_24
ENDIF
IF (ALLOCATED(SrcParamData%FX)) THEN
   i1_l = LBOUND(SrcParamData%FX,1)
   i1_u = UBOUND(SrcParamData%FX,1)
   IF (.NOT.ALLOCATED(DstParamData%FX)) THEN 
      ALLOCATE(DstParamData%FX(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%FX.'
         RETURN
      END IF
   END IF
   DstParamData%FX = SrcParamData%FX
ENDIF
IF (ALLOCATED(SrcParamData%C1_11)) THEN
   i1_l = LBOUND(SrcParamData%C1_11,1)
   i1_u = UBOUND(SrcParamData%C1_11,1)
   i2_l = LBOUND(SrcParamData%C1_11,2)
   i2_u = UBOUND(SrcParamData%C1_11,2)
   IF (.NOT.ALLOCATED(DstParamData%C1_11)) THEN 
      ALLOCATE(DstParamData%C1_11(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%C1_11.'
         RETURN
      END IF
   END IF
   DstParamData%C1_11 = SrcParamData%C1_11
ENDIF
IF (ALLOCATED(SrcParamData%C1_12)) THEN
   i1_l = LBOUND(SrcParamData%C1_12,1)
   i1_u = UBOUND(SrcParamData%C1_12,1)
   i2_l = LBOUND(SrcParamData%C1_12,2)
   i2_u = UBOUND(SrcParamData%C1_12,2)
   IF (.NOT.ALLOCATED(DstParamData%C1_12)) THEN 
      ALLOCATE(DstParamData%C1_12(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%C1_12.'
         RETURN
      END IF
   END IF
   DstParamData%C1_12 = SrcParamData%C1_12
ENDIF
IF (ALLOCATED(SrcParamData%D1_11)) THEN
   i1_l = LBOUND(SrcParamData%D1_11,1)
   i1_u = UBOUND(SrcParamData%D1_11,1)
   i2_l = LBOUND(SrcParamData%D1_11,2)
   i2_u = UBOUND(SrcParamData%D1_11,2)
   IF (.NOT.ALLOCATED(DstParamData%D1_11)) THEN 
      ALLOCATE(DstParamData%D1_11(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%D1_11.'
         RETURN
      END IF
   END IF
   DstParamData%D1_11 = SrcParamData%D1_11
ENDIF
IF (ALLOCATED(SrcParamData%D1_13)) THEN
   i1_l = LBOUND(SrcParamData%D1_13,1)
   i1_u = UBOUND(SrcParamData%D1_13,1)
   i2_l = LBOUND(SrcParamData%D1_13,2)
   i2_u = UBOUND(SrcParamData%D1_13,2)
   IF (.NOT.ALLOCATED(DstParamData%D1_13)) THEN 
      ALLOCATE(DstParamData%D1_13(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%D1_13.'
         RETURN
      END IF
   END IF
   DstParamData%D1_13 = SrcParamData%D1_13
ENDIF
IF (ALLOCATED(SrcParamData%D1_14)) THEN
   i1_l = LBOUND(SrcParamData%D1_14,1)
   i1_u = UBOUND(SrcParamData%D1_14,1)
   i2_l = LBOUND(SrcParamData%D1_14,2)
   i2_u = UBOUND(SrcParamData%D1_14,2)
   IF (.NOT.ALLOCATED(DstParamData%D1_14)) THEN 
      ALLOCATE(DstParamData%D1_14(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%D1_14.'
         RETURN
      END IF
   END IF
   DstParamData%D1_14 = SrcParamData%D1_14
ENDIF
IF (ALLOCATED(SrcParamData%FY)) THEN
   i1_l = LBOUND(SrcParamData%FY,1)
   i1_u = UBOUND(SrcParamData%FY,1)
   IF (.NOT.ALLOCATED(DstParamData%FY)) THEN 
      ALLOCATE(DstParamData%FY(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%FY.'
         RETURN
      END IF
   END IF
   DstParamData%FY = SrcParamData%FY
ENDIF
IF (ALLOCATED(SrcParamData%C2_21)) THEN
   i1_l = LBOUND(SrcParamData%C2_21,1)
   i1_u = UBOUND(SrcParamData%C2_21,1)
   i2_l = LBOUND(SrcParamData%C2_21,2)
   i2_u = UBOUND(SrcParamData%C2_21,2)
   IF (.NOT.ALLOCATED(DstParamData%C2_21)) THEN 
      ALLOCATE(DstParamData%C2_21(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%C2_21.'
         RETURN
      END IF
   END IF
   DstParamData%C2_21 = SrcParamData%C2_21
ENDIF
IF (ALLOCATED(SrcParamData%C2_42)) THEN
   i1_l = LBOUND(SrcParamData%C2_42,1)
   i1_u = UBOUND(SrcParamData%C2_42,1)
   i2_l = LBOUND(SrcParamData%C2_42,2)
   i2_u = UBOUND(SrcParamData%C2_42,2)
   IF (.NOT.ALLOCATED(DstParamData%C2_42)) THEN 
      ALLOCATE(DstParamData%C2_42(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%C2_42.'
         RETURN
      END IF
   END IF
   DstParamData%C2_42 = SrcParamData%C2_42
ENDIF
IF (ALLOCATED(SrcParamData%D2_11)) THEN
   i1_l = LBOUND(SrcParamData%D2_11,1)
   i1_u = UBOUND(SrcParamData%D2_11,1)
   i2_l = LBOUND(SrcParamData%D2_11,2)
   i2_u = UBOUND(SrcParamData%D2_11,2)
   IF (.NOT.ALLOCATED(DstParamData%D2_11)) THEN 
      ALLOCATE(DstParamData%D2_11(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%D2_11.'
         RETURN
      END IF
   END IF
   DstParamData%D2_11 = SrcParamData%D2_11
ENDIF
IF (ALLOCATED(SrcParamData%D2_21)) THEN
   i1_l = LBOUND(SrcParamData%D2_21,1)
   i1_u = UBOUND(SrcParamData%D2_21,1)
   i2_l = LBOUND(SrcParamData%D2_21,2)
   i2_u = UBOUND(SrcParamData%D2_21,2)
   IF (.NOT.ALLOCATED(DstParamData%D2_21)) THEN 
      ALLOCATE(DstParamData%D2_21(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%D2_21.'
         RETURN
      END IF
   END IF
   DstParamData%D2_21 = SrcParamData%D2_21
ENDIF
IF (ALLOCATED(SrcParamData%D2_32)) THEN
   i1_l = LBOUND(SrcParamData%D2_32,1)
   i1_u = UBOUND(SrcParamData%D2_32,1)
   i2_l = LBOUND(SrcParamData%D2_32,2)
   i2_u = UBOUND(SrcParamData%D2_32,2)
   IF (.NOT.ALLOCATED(DstParamData%D2_32)) THEN 
      ALLOCATE(DstParamData%D2_32(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%D2_32.'
         RETURN
      END IF
   END IF
   DstParamData%D2_32 = SrcParamData%D2_32
ENDIF
IF (ALLOCATED(SrcParamData%D2_42)) THEN
   i1_l = LBOUND(SrcParamData%D2_42,1)
   i1_u = UBOUND(SrcParamData%D2_42,1)
   i2_l = LBOUND(SrcParamData%D2_42,2)
   i2_u = UBOUND(SrcParamData%D2_42,2)
   IF (.NOT.ALLOCATED(DstParamData%D2_42)) THEN 
      ALLOCATE(DstParamData%D2_42(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%D2_42.'
         RETURN
      END IF
   END IF
   DstParamData%D2_42 = SrcParamData%D2_42
ENDIF
IF (ALLOCATED(SrcParamData%Cbar_21)) THEN
   i1_l = LBOUND(SrcParamData%Cbar_21,1)
   i1_u = UBOUND(SrcParamData%Cbar_21,1)
   i2_l = LBOUND(SrcParamData%Cbar_21,2)
   i2_u = UBOUND(SrcParamData%Cbar_21,2)
   IF (.NOT.ALLOCATED(DstParamData%Cbar_21)) THEN 
      ALLOCATE(DstParamData%Cbar_21(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Cbar_21.'
         RETURN
      END IF
   END IF
   DstParamData%Cbar_21 = SrcParamData%Cbar_21
ENDIF
IF (ALLOCATED(SrcParamData%Cbar_22)) THEN
   i1_l = LBOUND(SrcParamData%Cbar_22,1)
   i1_u = UBOUND(SrcParamData%Cbar_22,1)
   i2_l = LBOUND(SrcParamData%Cbar_22,2)
   i2_u = UBOUND(SrcParamData%Cbar_22,2)
   IF (.NOT.ALLOCATED(DstParamData%Cbar_22)) THEN 
      ALLOCATE(DstParamData%Cbar_22(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Cbar_22.'
         RETURN
      END IF
   END IF
   DstParamData%Cbar_22 = SrcParamData%Cbar_22
ENDIF
IF (ALLOCATED(SrcParamData%Dbar_13)) THEN
   i1_l = LBOUND(SrcParamData%Dbar_13,1)
   i1_u = UBOUND(SrcParamData%Dbar_13,1)
   i2_l = LBOUND(SrcParamData%Dbar_13,2)
   i2_u = UBOUND(SrcParamData%Dbar_13,2)
   IF (.NOT.ALLOCATED(DstParamData%Dbar_13)) THEN 
      ALLOCATE(DstParamData%Dbar_13(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Dbar_13.'
         RETURN
      END IF
   END IF
   DstParamData%Dbar_13 = SrcParamData%Dbar_13
ENDIF
IF (ALLOCATED(SrcParamData%Dbar_23)) THEN
   i1_l = LBOUND(SrcParamData%Dbar_23,1)
   i1_u = UBOUND(SrcParamData%Dbar_23,1)
   i2_l = LBOUND(SrcParamData%Dbar_23,2)
   i2_u = UBOUND(SrcParamData%Dbar_23,2)
   IF (.NOT.ALLOCATED(DstParamData%Dbar_23)) THEN 
      ALLOCATE(DstParamData%Dbar_23(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Dbar_23.'
         RETURN
      END IF
   END IF
   DstParamData%Dbar_23 = SrcParamData%Dbar_23
ENDIF
IF (ALLOCATED(SrcParamData%Dbar_24)) THEN
   i1_l = LBOUND(SrcParamData%Dbar_24,1)
   i1_u = UBOUND(SrcParamData%Dbar_24,1)
   i2_l = LBOUND(SrcParamData%Dbar_24,2)
   i2_u = UBOUND(SrcParamData%Dbar_24,2)
   IF (.NOT.ALLOCATED(DstParamData%Dbar_24)) THEN 
      ALLOCATE(DstParamData%Dbar_24(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Dbar_24.'
         RETURN
      END IF
   END IF
   DstParamData%Dbar_24 = SrcParamData%Dbar_24
ENDIF
IF (ALLOCATED(SrcParamData%Fbar_21)) THEN
   i1_l = LBOUND(SrcParamData%Fbar_21,1)
   i1_u = UBOUND(SrcParamData%Fbar_21,1)
   IF (.NOT.ALLOCATED(DstParamData%Fbar_21)) THEN 
      ALLOCATE(DstParamData%Fbar_21(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Fbar_21.'
         RETURN
      END IF
   END IF
   DstParamData%Fbar_21 = SrcParamData%Fbar_21
ENDIF
IF (ALLOCATED(SrcParamData%MBB)) THEN
   i1_l = LBOUND(SrcParamData%MBB,1)
   i1_u = UBOUND(SrcParamData%MBB,1)
   i2_l = LBOUND(SrcParamData%MBB,2)
   i2_u = UBOUND(SrcParamData%MBB,2)
   IF (.NOT.ALLOCATED(DstParamData%MBB)) THEN 
      ALLOCATE(DstParamData%MBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%MBB.'
         RETURN
      END IF
   END IF
   DstParamData%MBB = SrcParamData%MBB
ENDIF
IF (ALLOCATED(SrcParamData%KBB)) THEN
   i1_l = LBOUND(SrcParamData%KBB,1)
   i1_u = UBOUND(SrcParamData%KBB,1)
   i2_l = LBOUND(SrcParamData%KBB,2)
   i2_u = UBOUND(SrcParamData%KBB,2)
   IF (.NOT.ALLOCATED(DstParamData%KBB)) THEN 
      ALLOCATE(DstParamData%KBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%KBB.'
         RETURN
      END IF
   END IF
   DstParamData%KBB = SrcParamData%KBB
ENDIF
IF (ALLOCATED(SrcParamData%MBM)) THEN
   i1_l = LBOUND(SrcParamData%MBM,1)
   i1_u = UBOUND(SrcParamData%MBM,1)
   i2_l = LBOUND(SrcParamData%MBM,2)
   i2_u = UBOUND(SrcParamData%MBM,2)
   IF (.NOT.ALLOCATED(DstParamData%MBM)) THEN 
      ALLOCATE(DstParamData%MBM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%MBM.'
         RETURN
      END IF
   END IF
   DstParamData%MBM = SrcParamData%MBM
ENDIF
IF (ALLOCATED(SrcParamData%PHI_R)) THEN
   i1_l = LBOUND(SrcParamData%PHI_R,1)
   i1_u = UBOUND(SrcParamData%PHI_R,1)
   i2_l = LBOUND(SrcParamData%PHI_R,2)
   i2_u = UBOUND(SrcParamData%PHI_R,2)
   IF (.NOT.ALLOCATED(DstParamData%PHI_R)) THEN 
      ALLOCATE(DstParamData%PHI_R(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%PHI_R.'
         RETURN
      END IF
   END IF
   DstParamData%PHI_R = SrcParamData%PHI_R
ENDIF
IF (ALLOCATED(SrcParamData%PHI_M)) THEN
   i1_l = LBOUND(SrcParamData%PHI_M,1)
   i1_u = UBOUND(SrcParamData%PHI_M,1)
   i2_l = LBOUND(SrcParamData%PHI_M,2)
   i2_u = UBOUND(SrcParamData%PHI_M,2)
   IF (.NOT.ALLOCATED(DstParamData%PHI_M)) THEN 
      ALLOCATE(DstParamData%PHI_M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%PHI_M.'
         RETURN
      END IF
   END IF
   DstParamData%PHI_M = SrcParamData%PHI_M
ENDIF
IF (ALLOCATED(SrcParamData%AM2InvJac)) THEN
   i1_l = LBOUND(SrcParamData%AM2InvJac,1)
   i1_u = UBOUND(SrcParamData%AM2InvJac,1)
   i2_l = LBOUND(SrcParamData%AM2InvJac,2)
   i2_u = UBOUND(SrcParamData%AM2InvJac,2)
   IF (.NOT.ALLOCATED(DstParamData%AM2InvJac)) THEN 
      ALLOCATE(DstParamData%AM2InvJac(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%AM2InvJac.'
         RETURN
      END IF
   END IF
   DstParamData%AM2InvJac = SrcParamData%AM2InvJac
ENDIF
IF (ALLOCATED(SrcParamData%TI)) THEN
   i1_l = LBOUND(SrcParamData%TI,1)
   i1_u = UBOUND(SrcParamData%TI,1)
   i2_l = LBOUND(SrcParamData%TI,2)
   i2_u = UBOUND(SrcParamData%TI,2)
   IF (.NOT.ALLOCATED(DstParamData%TI)) THEN 
      ALLOCATE(DstParamData%TI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%TI.'
         RETURN
      END IF
   END IF
   DstParamData%TI = SrcParamData%TI
ENDIF
IF (ALLOCATED(SrcParamData%TIreact)) THEN
   i1_l = LBOUND(SrcParamData%TIreact,1)
   i1_u = UBOUND(SrcParamData%TIreact,1)
   i2_l = LBOUND(SrcParamData%TIreact,2)
   i2_u = UBOUND(SrcParamData%TIreact,2)
   IF (.NOT.ALLOCATED(DstParamData%TIreact)) THEN 
      ALLOCATE(DstParamData%TIreact(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%TIreact.'
         RETURN
      END IF
   END IF
   DstParamData%TIreact = SrcParamData%TIreact
ENDIF
   DstParamData%NModes = SrcParamData%NModes
IF (ALLOCATED(SrcParamData%Elems)) THEN
   i1_l = LBOUND(SrcParamData%Elems,1)
   i1_u = UBOUND(SrcParamData%Elems,1)
   i2_l = LBOUND(SrcParamData%Elems,2)
   i2_u = UBOUND(SrcParamData%Elems,2)
   IF (.NOT.ALLOCATED(DstParamData%Elems)) THEN 
      ALLOCATE(DstParamData%Elems(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Elems.'
         RETURN
      END IF
   END IF
   DstParamData%Elems = SrcParamData%Elems
ENDIF
   DstParamData%qmL = SrcParamData%qmL
   DstParamData%uL = SrcParamData%uL
   DstParamData%DofL = SrcParamData%DofL
   DstParamData%NNodes_I = SrcParamData%NNodes_I
   DstParamData%NNodes_L = SrcParamData%NNodes_L
   DstParamData%NNodes_RbarL = SrcParamData%NNodes_RbarL
   DstParamData%DofI = SrcParamData%DofI
   DstParamData%DofR = SrcParamData%DofR
   DstParamData%DofRbarL = SrcParamData%DofRbarL
   DstParamData%DofC = SrcParamData%DofC
   DstParamData%NReact = SrcParamData%NReact
IF (ALLOCATED(SrcParamData%Reacts)) THEN
   i1_l = LBOUND(SrcParamData%Reacts,1)
   i1_u = UBOUND(SrcParamData%Reacts,1)
   i2_l = LBOUND(SrcParamData%Reacts,2)
   i2_u = UBOUND(SrcParamData%Reacts,2)
   IF (.NOT.ALLOCATED(DstParamData%Reacts)) THEN 
      ALLOCATE(DstParamData%Reacts(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%Reacts.'
         RETURN
      END IF
   END IF
   DstParamData%Reacts = SrcParamData%Reacts
ENDIF
   DstParamData%Nmembers = SrcParamData%Nmembers
   DstParamData%TPdofL = SrcParamData%TPdofL
   DstParamData%URbarL = SrcParamData%URbarL
   DstParamData%URdotdotL = SrcParamData%URdotdotL
   DstParamData%UdotdotL = SrcParamData%UdotdotL
   DstParamData%Y2L = SrcParamData%Y2L
   DstParamData%IntMethod = SrcParamData%IntMethod
   DstParamData%NAvgEls = SrcParamData%NAvgEls
IF (ALLOCATED(SrcParamData%IDI)) THEN
   i1_l = LBOUND(SrcParamData%IDI,1)
   i1_u = UBOUND(SrcParamData%IDI,1)
   IF (.NOT.ALLOCATED(DstParamData%IDI)) THEN 
      ALLOCATE(DstParamData%IDI(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%IDI.'
         RETURN
      END IF
   END IF
   DstParamData%IDI = SrcParamData%IDI
ENDIF
IF (ALLOCATED(SrcParamData%IDR)) THEN
   i1_l = LBOUND(SrcParamData%IDR,1)
   i1_u = UBOUND(SrcParamData%IDR,1)
   IF (.NOT.ALLOCATED(DstParamData%IDR)) THEN 
      ALLOCATE(DstParamData%IDR(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%IDR.'
         RETURN
      END IF
   END IF
   DstParamData%IDR = SrcParamData%IDR
ENDIF
IF (ALLOCATED(SrcParamData%IDL)) THEN
   i1_l = LBOUND(SrcParamData%IDL,1)
   i1_u = UBOUND(SrcParamData%IDL,1)
   IF (.NOT.ALLOCATED(DstParamData%IDL)) THEN 
      ALLOCATE(DstParamData%IDL(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%IDL.'
         RETURN
      END IF
   END IF
   DstParamData%IDL = SrcParamData%IDL
ENDIF
IF (ALLOCATED(SrcParamData%IDC)) THEN
   i1_l = LBOUND(SrcParamData%IDC,1)
   i1_u = UBOUND(SrcParamData%IDC,1)
   IF (.NOT.ALLOCATED(DstParamData%IDC)) THEN 
      ALLOCATE(DstParamData%IDC(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%IDC.'
         RETURN
      END IF
   END IF
   DstParamData%IDC = SrcParamData%IDC
ENDIF
IF (ALLOCATED(SrcParamData%IDY)) THEN
   i1_l = LBOUND(SrcParamData%IDY,1)
   i1_u = UBOUND(SrcParamData%IDY,1)
   IF (.NOT.ALLOCATED(DstParamData%IDY)) THEN 
      ALLOCATE(DstParamData%IDY(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%IDY.'
         RETURN
      END IF
   END IF
   DstParamData%IDY = SrcParamData%IDY
ENDIF
   DstParamData%NMOutputs = SrcParamData%NMOutputs
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%SDDeltaT = SrcParamData%SDDeltaT
   DstParamData%OutSwtch = SrcParamData%OutSwtch
   DstParamData%UnJckF = SrcParamData%UnJckF
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutSFmt = SrcParamData%OutSFmt
   DstParamData%OutJckF = SrcParamData%OutJckF
IF (ALLOCATED(SrcParamData%MoutLst)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst,1)
   i1_u = UBOUND(SrcParamData%MoutLst,1)
   IF (.NOT.ALLOCATED(DstParamData%MoutLst)) THEN 
      ALLOCATE(DstParamData%MoutLst(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%MoutLst.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst,1), UBOUND(SrcParamData%MoutLst,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst(i1), DstParamData%MoutLst(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst2)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst2,1)
   i1_u = UBOUND(SrcParamData%MoutLst2,1)
   IF (.NOT.ALLOCATED(DstParamData%MoutLst2)) THEN 
      ALLOCATE(DstParamData%MoutLst2(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%MoutLst2.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst2,1), UBOUND(SrcParamData%MoutLst2,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst2(i1), DstParamData%MoutLst2(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst3)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst3,1)
   i1_u = UBOUND(SrcParamData%MoutLst3,1)
   IF (.NOT.ALLOCATED(DstParamData%MoutLst3)) THEN 
      ALLOCATE(DstParamData%MoutLst3(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%MoutLst3.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst3,1), UBOUND(SrcParamData%MoutLst3,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst3(i1), DstParamData%MoutLst3(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%ElemProps)) THEN
   i1_l = LBOUND(SrcParamData%ElemProps,1)
   i1_u = UBOUND(SrcParamData%ElemProps,1)
   IF (.NOT.ALLOCATED(DstParamData%ElemProps)) THEN 
      ALLOCATE(DstParamData%ElemProps(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%ElemProps.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%ElemProps,1), UBOUND(SrcParamData%ElemProps,1)
      CALL SD_Copyelemproptype( SrcParamData%ElemProps(i1), DstParamData%ElemProps(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT.ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyParam: Error allocating DstParamData%OutParam.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL SD_Copyoutvar_type( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
   DstParamData%OutAll = SrcParamData%OutAll
   DstParamData%OutReact = SrcParamData%OutReact
   DstParamData%OutAllInt = SrcParamData%OutAllInt
   DstParamData%OutAllDims = SrcParamData%OutAllDims
   DstParamData%OutDec = SrcParamData%OutDec
   DstParamData%MaxOUtPts = SrcParamData%MaxOUtPts
 END SUBROUTINE SD_CopyParam

 SUBROUTINE SD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SD_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%A_21)) THEN
   DEALLOCATE(ParamData%A_21)
ENDIF
IF (ALLOCATED(ParamData%A_22)) THEN
   DEALLOCATE(ParamData%A_22)
ENDIF
IF (ALLOCATED(ParamData%B_23)) THEN
   DEALLOCATE(ParamData%B_23)
ENDIF
IF (ALLOCATED(ParamData%B_24)) THEN
   DEALLOCATE(ParamData%B_24)
ENDIF
IF (ALLOCATED(ParamData%FX)) THEN
   DEALLOCATE(ParamData%FX)
ENDIF
IF (ALLOCATED(ParamData%C1_11)) THEN
   DEALLOCATE(ParamData%C1_11)
ENDIF
IF (ALLOCATED(ParamData%C1_12)) THEN
   DEALLOCATE(ParamData%C1_12)
ENDIF
IF (ALLOCATED(ParamData%D1_11)) THEN
   DEALLOCATE(ParamData%D1_11)
ENDIF
IF (ALLOCATED(ParamData%D1_13)) THEN
   DEALLOCATE(ParamData%D1_13)
ENDIF
IF (ALLOCATED(ParamData%D1_14)) THEN
   DEALLOCATE(ParamData%D1_14)
ENDIF
IF (ALLOCATED(ParamData%FY)) THEN
   DEALLOCATE(ParamData%FY)
ENDIF
IF (ALLOCATED(ParamData%C2_21)) THEN
   DEALLOCATE(ParamData%C2_21)
ENDIF
IF (ALLOCATED(ParamData%C2_42)) THEN
   DEALLOCATE(ParamData%C2_42)
ENDIF
IF (ALLOCATED(ParamData%D2_11)) THEN
   DEALLOCATE(ParamData%D2_11)
ENDIF
IF (ALLOCATED(ParamData%D2_21)) THEN
   DEALLOCATE(ParamData%D2_21)
ENDIF
IF (ALLOCATED(ParamData%D2_32)) THEN
   DEALLOCATE(ParamData%D2_32)
ENDIF
IF (ALLOCATED(ParamData%D2_42)) THEN
   DEALLOCATE(ParamData%D2_42)
ENDIF
IF (ALLOCATED(ParamData%Cbar_21)) THEN
   DEALLOCATE(ParamData%Cbar_21)
ENDIF
IF (ALLOCATED(ParamData%Cbar_22)) THEN
   DEALLOCATE(ParamData%Cbar_22)
ENDIF
IF (ALLOCATED(ParamData%Dbar_13)) THEN
   DEALLOCATE(ParamData%Dbar_13)
ENDIF
IF (ALLOCATED(ParamData%Dbar_23)) THEN
   DEALLOCATE(ParamData%Dbar_23)
ENDIF
IF (ALLOCATED(ParamData%Dbar_24)) THEN
   DEALLOCATE(ParamData%Dbar_24)
ENDIF
IF (ALLOCATED(ParamData%Fbar_21)) THEN
   DEALLOCATE(ParamData%Fbar_21)
ENDIF
IF (ALLOCATED(ParamData%MBB)) THEN
   DEALLOCATE(ParamData%MBB)
ENDIF
IF (ALLOCATED(ParamData%KBB)) THEN
   DEALLOCATE(ParamData%KBB)
ENDIF
IF (ALLOCATED(ParamData%MBM)) THEN
   DEALLOCATE(ParamData%MBM)
ENDIF
IF (ALLOCATED(ParamData%PHI_R)) THEN
   DEALLOCATE(ParamData%PHI_R)
ENDIF
IF (ALLOCATED(ParamData%PHI_M)) THEN
   DEALLOCATE(ParamData%PHI_M)
ENDIF
IF (ALLOCATED(ParamData%AM2InvJac)) THEN
   DEALLOCATE(ParamData%AM2InvJac)
ENDIF
IF (ALLOCATED(ParamData%TI)) THEN
   DEALLOCATE(ParamData%TI)
ENDIF
IF (ALLOCATED(ParamData%TIreact)) THEN
   DEALLOCATE(ParamData%TIreact)
ENDIF
IF (ALLOCATED(ParamData%Elems)) THEN
   DEALLOCATE(ParamData%Elems)
ENDIF
IF (ALLOCATED(ParamData%Reacts)) THEN
   DEALLOCATE(ParamData%Reacts)
ENDIF
IF (ALLOCATED(ParamData%IDI)) THEN
   DEALLOCATE(ParamData%IDI)
ENDIF
IF (ALLOCATED(ParamData%IDR)) THEN
   DEALLOCATE(ParamData%IDR)
ENDIF
IF (ALLOCATED(ParamData%IDL)) THEN
   DEALLOCATE(ParamData%IDL)
ENDIF
IF (ALLOCATED(ParamData%IDC)) THEN
   DEALLOCATE(ParamData%IDC)
ENDIF
IF (ALLOCATED(ParamData%IDY)) THEN
   DEALLOCATE(ParamData%IDY)
ENDIF
IF (ALLOCATED(ParamData%MoutLst)) THEN
DO i1 = LBOUND(ParamData%MoutLst,1), UBOUND(ParamData%MoutLst,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst)
ENDIF
IF (ALLOCATED(ParamData%MoutLst2)) THEN
DO i1 = LBOUND(ParamData%MoutLst2,1), UBOUND(ParamData%MoutLst2,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst2(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst2)
ENDIF
IF (ALLOCATED(ParamData%MoutLst3)) THEN
DO i1 = LBOUND(ParamData%MoutLst3,1), UBOUND(ParamData%MoutLst3,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst3(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst3)
ENDIF
IF (ALLOCATED(ParamData%ElemProps)) THEN
DO i1 = LBOUND(ParamData%ElemProps,1), UBOUND(ParamData%ElemProps,1)
  CALL SD_Destroyelemproptype( ParamData%ElemProps(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%ElemProps)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL SD_Destroyoutvar_type( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE SD_DestroyParam

 SUBROUTINE SD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%A_21 )  ! A_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%A_22 )  ! A_22 
  Re_BufSz    = Re_BufSz    + SIZE( InData%B_23 )  ! B_23 
  Re_BufSz    = Re_BufSz    + SIZE( InData%B_24 )  ! B_24 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FX )  ! FX 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C1_11 )  ! C1_11 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C1_12 )  ! C1_12 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D1_11 )  ! D1_11 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D1_13 )  ! D1_13 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D1_14 )  ! D1_14 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FY )  ! FY 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C2_21 )  ! C2_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%C2_42 )  ! C2_42 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_11 )  ! D2_11 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_21 )  ! D2_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_32 )  ! D2_32 
  Re_BufSz    = Re_BufSz    + SIZE( InData%D2_42 )  ! D2_42 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Cbar_21 )  ! Cbar_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Cbar_22 )  ! Cbar_22 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Dbar_13 )  ! Dbar_13 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Dbar_23 )  ! Dbar_23 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Dbar_24 )  ! Dbar_24 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fbar_21 )  ! Fbar_21 
  Re_BufSz    = Re_BufSz    + SIZE( InData%MBB )  ! MBB 
  Re_BufSz    = Re_BufSz    + SIZE( InData%KBB )  ! KBB 
  Re_BufSz    = Re_BufSz    + SIZE( InData%MBM )  ! MBM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PHI_R )  ! PHI_R 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PHI_M )  ! PHI_M 
  Re_BufSz    = Re_BufSz    + SIZE( InData%AM2InvJac )  ! AM2InvJac 
  Re_BufSz    = Re_BufSz    + SIZE( InData%TI )  ! TI 
  Re_BufSz    = Re_BufSz    + SIZE( InData%TIreact )  ! TIreact 
  Int_BufSz  = Int_BufSz  + 1  ! NModes
  Int_BufSz   = Int_BufSz   + SIZE( InData%Elems )  ! Elems 
  Int_BufSz  = Int_BufSz  + 1  ! qmL
  Int_BufSz  = Int_BufSz  + 1  ! uL
  Int_BufSz  = Int_BufSz  + 1  ! DofL
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_I
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_L
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_RbarL
  Int_BufSz  = Int_BufSz  + 1  ! DofI
  Int_BufSz  = Int_BufSz  + 1  ! DofR
  Int_BufSz  = Int_BufSz  + 1  ! DofRbarL
  Int_BufSz  = Int_BufSz  + 1  ! DofC
  Int_BufSz  = Int_BufSz  + 1  ! NReact
  Int_BufSz   = Int_BufSz   + SIZE( InData%Reacts )  ! Reacts 
  Int_BufSz  = Int_BufSz  + 1  ! Nmembers
  Int_BufSz  = Int_BufSz  + 1  ! TPdofL
  Int_BufSz  = Int_BufSz  + 1  ! URbarL
  Int_BufSz  = Int_BufSz  + 1  ! URdotdotL
  Int_BufSz  = Int_BufSz  + 1  ! UdotdotL
  Int_BufSz  = Int_BufSz  + 1  ! Y2L
  Int_BufSz  = Int_BufSz  + 1  ! IntMethod
  Int_BufSz  = Int_BufSz  + 1  ! NAvgEls
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDI )  ! IDI 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDR )  ! IDR 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDL )  ! IDL 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDC )  ! IDC 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDY )  ! IDY 
  Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Db_BufSz   = Db_BufSz   + 1  ! SDDeltaT
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
  Int_BufSz  = Int_BufSz  + 1  ! UnJckF
DO i1 = LBOUND(InData%MoutLst,1), UBOUND(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Db_MoutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Int_MoutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst_Buf ) ! MoutLst
  IF(ALLOCATED(Re_MoutLst_Buf))  DEALLOCATE(Re_MoutLst_Buf)
  IF(ALLOCATED(Db_MoutLst_Buf))  DEALLOCATE(Db_MoutLst_Buf)
  IF(ALLOCATED(Int_MoutLst_Buf)) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst2,1), UBOUND(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Db_MoutLst2_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Int_MoutLst2_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst2_Buf ) ! MoutLst2
  IF(ALLOCATED(Re_MoutLst2_Buf))  DEALLOCATE(Re_MoutLst2_Buf)
  IF(ALLOCATED(Db_MoutLst2_Buf))  DEALLOCATE(Db_MoutLst2_Buf)
  IF(ALLOCATED(Int_MoutLst2_Buf)) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst3,1), UBOUND(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Db_MoutLst3_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Int_MoutLst3_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst3_Buf ) ! MoutLst3
  IF(ALLOCATED(Re_MoutLst3_Buf))  DEALLOCATE(Re_MoutLst3_Buf)
  IF(ALLOCATED(Db_MoutLst3_Buf))  DEALLOCATE(Db_MoutLst3_Buf)
  IF(ALLOCATED(Int_MoutLst3_Buf)) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = LBOUND(InData%ElemProps,1), UBOUND(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Db_ElemProps_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Int_ElemProps_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ElemProps_Buf ) ! ElemProps
  IF(ALLOCATED(Re_ElemProps_Buf))  DEALLOCATE(Re_ElemProps_Buf)
  IF(ALLOCATED(Db_ElemProps_Buf))  DEALLOCATE(Db_ElemProps_Buf)
  IF(ALLOCATED(Int_ElemProps_Buf)) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL SD_Packoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! OutAllInt
  Int_BufSz  = Int_BufSz  + 1  ! OutAllDims
  Int_BufSz  = Int_BufSz  + 1  ! OutDec
  Int_BufSz  = Int_BufSz  + 1  ! MaxOUtPts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%A_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%A_21))-1 ) =  PACK(InData%A_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%A_21)
  ENDIF
  IF ( ALLOCATED(InData%A_22) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%A_22))-1 ) =  PACK(InData%A_22 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%A_22)
  ENDIF
  IF ( ALLOCATED(InData%B_23) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%B_23))-1 ) =  PACK(InData%B_23 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%B_23)
  ENDIF
  IF ( ALLOCATED(InData%B_24) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%B_24))-1 ) =  PACK(InData%B_24 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%B_24)
  ENDIF
  IF ( ALLOCATED(InData%FX) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FX)
  ENDIF
  IF ( ALLOCATED(InData%C1_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_11))-1 ) =  PACK(InData%C1_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_11)
  ENDIF
  IF ( ALLOCATED(InData%C1_12) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_12))-1 ) =  PACK(InData%C1_12 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_12)
  ENDIF
  IF ( ALLOCATED(InData%D1_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_11))-1 ) =  PACK(InData%D1_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_11)
  ENDIF
  IF ( ALLOCATED(InData%D1_13) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_13))-1 ) =  PACK(InData%D1_13 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_13)
  ENDIF
  IF ( ALLOCATED(InData%D1_14) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_14))-1 ) =  PACK(InData%D1_14 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_14)
  ENDIF
  IF ( ALLOCATED(InData%FY) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FY)
  ENDIF
  IF ( ALLOCATED(InData%C2_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_21))-1 ) =  PACK(InData%C2_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_21)
  ENDIF
  IF ( ALLOCATED(InData%C2_42) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_42))-1 ) =  PACK(InData%C2_42 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_42)
  ENDIF
  IF ( ALLOCATED(InData%D2_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_11))-1 ) =  PACK(InData%D2_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_11)
  ENDIF
  IF ( ALLOCATED(InData%D2_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_21))-1 ) =  PACK(InData%D2_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_21)
  ENDIF
  IF ( ALLOCATED(InData%D2_32) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_32))-1 ) =  PACK(InData%D2_32 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_32)
  ENDIF
  IF ( ALLOCATED(InData%D2_42) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_42))-1 ) =  PACK(InData%D2_42 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_42)
  ENDIF
  IF ( ALLOCATED(InData%Cbar_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cbar_21))-1 ) =  PACK(InData%Cbar_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cbar_21)
  ENDIF
  IF ( ALLOCATED(InData%Cbar_22) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cbar_22))-1 ) =  PACK(InData%Cbar_22 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cbar_22)
  ENDIF
  IF ( ALLOCATED(InData%Dbar_13) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dbar_13))-1 ) =  PACK(InData%Dbar_13 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dbar_13)
  ENDIF
  IF ( ALLOCATED(InData%Dbar_23) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dbar_23))-1 ) =  PACK(InData%Dbar_23 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dbar_23)
  ENDIF
  IF ( ALLOCATED(InData%Dbar_24) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dbar_24))-1 ) =  PACK(InData%Dbar_24 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dbar_24)
  ENDIF
  IF ( ALLOCATED(InData%Fbar_21) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fbar_21))-1 ) =  PACK(InData%Fbar_21 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fbar_21)
  ENDIF
  IF ( ALLOCATED(InData%MBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBB))-1 ) =  PACK(InData%MBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBB)
  ENDIF
  IF ( ALLOCATED(InData%KBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%KBB))-1 ) =  PACK(InData%KBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%KBB)
  ENDIF
  IF ( ALLOCATED(InData%MBM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBM))-1 ) =  PACK(InData%MBM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBM)
  ENDIF
  IF ( ALLOCATED(InData%PHI_R) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PHI_R))-1 ) =  PACK(InData%PHI_R ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PHI_R)
  ENDIF
  IF ( ALLOCATED(InData%PHI_M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PHI_M))-1 ) =  PACK(InData%PHI_M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PHI_M)
  ENDIF
  IF ( ALLOCATED(InData%AM2InvJac) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AM2InvJac))-1 ) =  PACK(InData%AM2InvJac ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%AM2InvJac)
  ENDIF
  IF ( ALLOCATED(InData%TI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TI))-1 ) =  PACK(InData%TI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TI)
  ENDIF
  IF ( ALLOCATED(InData%TIreact) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TIreact))-1 ) =  PACK(InData%TIreact ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TIreact)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NModes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Elems) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Elems))-1 ) = PACK(InData%Elems ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Elems)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%qmL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%uL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_I )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_L )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_RbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofI )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofR )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofRbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofC )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NReact )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Reacts) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Reacts))-1 ) = PACK(InData%Reacts ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Reacts)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Nmembers )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TPdofL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%URbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%URdotdotL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UdotdotL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Y2L )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IntMethod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NAvgEls )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%IDI) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDI))-1 ) = PACK(InData%IDI ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDI)
  ENDIF
  IF ( ALLOCATED(InData%IDR) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDR))-1 ) = PACK(InData%IDR ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDR)
  ENDIF
  IF ( ALLOCATED(InData%IDL) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDL))-1 ) = PACK(InData%IDL ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDL)
  ENDIF
  IF ( ALLOCATED(InData%IDC) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDC))-1 ) = PACK(InData%IDC ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDC)
  ENDIF
  IF ( ALLOCATED(InData%IDY) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDY))-1 ) = PACK(InData%IDY ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDY)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMOutputs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%SDDeltaT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnJckF )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%MoutLst,1), UBOUND(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 ) = Re_MoutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 ) = Db_MoutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 ) = Int_MoutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst_Buf) )  DEALLOCATE(Re_MoutLst_Buf)
  IF( ALLOCATED(Db_MoutLst_Buf) )  DEALLOCATE(Db_MoutLst_Buf)
  IF( ALLOCATED(Int_MoutLst_Buf) ) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst2,1), UBOUND(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 ) = Re_MoutLst2_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 ) = Db_MoutLst2_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 ) = Int_MoutLst2_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst2_Buf) )  DEALLOCATE(Re_MoutLst2_Buf)
  IF( ALLOCATED(Db_MoutLst2_Buf) )  DEALLOCATE(Db_MoutLst2_Buf)
  IF( ALLOCATED(Int_MoutLst2_Buf) ) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst3,1), UBOUND(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 ) = Re_MoutLst3_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 ) = Db_MoutLst3_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 ) = Int_MoutLst3_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst3_Buf) )  DEALLOCATE(Re_MoutLst3_Buf)
  IF( ALLOCATED(Db_MoutLst3_Buf) )  DEALLOCATE(Db_MoutLst3_Buf)
  IF( ALLOCATED(Int_MoutLst3_Buf) ) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = LBOUND(InData%ElemProps,1), UBOUND(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, OnlySize ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 ) = Re_ElemProps_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 ) = Db_ElemProps_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 ) = Int_ElemProps_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  IF( ALLOCATED(Re_ElemProps_Buf) )  DEALLOCATE(Re_ElemProps_Buf)
  IF( ALLOCATED(Db_ElemProps_Buf) )  DEALLOCATE(Db_ElemProps_Buf)
  IF( ALLOCATED(Int_ElemProps_Buf) ) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL SD_Packoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllInt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllDims )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutDec )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxOUtPts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackParam

 SUBROUTINE SD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%A_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%A_21,1),SIZE(OutData%A_21,2))); mask2 = .TRUE.
    OutData%A_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%A_21))-1 ),mask2,OutData%A_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%A_21)
  ENDIF
  IF ( ALLOCATED(OutData%A_22) ) THEN
  ALLOCATE(mask2(SIZE(OutData%A_22,1),SIZE(OutData%A_22,2))); mask2 = .TRUE.
    OutData%A_22 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%A_22))-1 ),mask2,OutData%A_22)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%A_22)
  ENDIF
  IF ( ALLOCATED(OutData%B_23) ) THEN
  ALLOCATE(mask2(SIZE(OutData%B_23,1),SIZE(OutData%B_23,2))); mask2 = .TRUE.
    OutData%B_23 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%B_23))-1 ),mask2,OutData%B_23)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%B_23)
  ENDIF
  IF ( ALLOCATED(OutData%B_24) ) THEN
  ALLOCATE(mask2(SIZE(OutData%B_24,1),SIZE(OutData%B_24,2))); mask2 = .TRUE.
    OutData%B_24 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%B_24))-1 ),mask2,OutData%B_24)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%B_24)
  ENDIF
  IF ( ALLOCATED(OutData%FX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FX,1))); mask1 = .TRUE.
    OutData%FX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FX)
  ENDIF
  IF ( ALLOCATED(OutData%C1_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_11,1),SIZE(OutData%C1_11,2))); mask2 = .TRUE.
    OutData%C1_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_11))-1 ),mask2,OutData%C1_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_11)
  ENDIF
  IF ( ALLOCATED(OutData%C1_12) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_12,1),SIZE(OutData%C1_12,2))); mask2 = .TRUE.
    OutData%C1_12 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_12))-1 ),mask2,OutData%C1_12)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_12)
  ENDIF
  IF ( ALLOCATED(OutData%D1_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_11,1),SIZE(OutData%D1_11,2))); mask2 = .TRUE.
    OutData%D1_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_11))-1 ),mask2,OutData%D1_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_11)
  ENDIF
  IF ( ALLOCATED(OutData%D1_13) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_13,1),SIZE(OutData%D1_13,2))); mask2 = .TRUE.
    OutData%D1_13 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_13))-1 ),mask2,OutData%D1_13)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_13)
  ENDIF
  IF ( ALLOCATED(OutData%D1_14) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_14,1),SIZE(OutData%D1_14,2))); mask2 = .TRUE.
    OutData%D1_14 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_14))-1 ),mask2,OutData%D1_14)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_14)
  ENDIF
  IF ( ALLOCATED(OutData%FY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FY,1))); mask1 = .TRUE.
    OutData%FY = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FY)
  ENDIF
  IF ( ALLOCATED(OutData%C2_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_21,1),SIZE(OutData%C2_21,2))); mask2 = .TRUE.
    OutData%C2_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_21))-1 ),mask2,OutData%C2_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_21)
  ENDIF
  IF ( ALLOCATED(OutData%C2_42) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_42,1),SIZE(OutData%C2_42,2))); mask2 = .TRUE.
    OutData%C2_42 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_42))-1 ),mask2,OutData%C2_42)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_42)
  ENDIF
  IF ( ALLOCATED(OutData%D2_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_11,1),SIZE(OutData%D2_11,2))); mask2 = .TRUE.
    OutData%D2_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_11))-1 ),mask2,OutData%D2_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_11)
  ENDIF
  IF ( ALLOCATED(OutData%D2_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_21,1),SIZE(OutData%D2_21,2))); mask2 = .TRUE.
    OutData%D2_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_21))-1 ),mask2,OutData%D2_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_21)
  ENDIF
  IF ( ALLOCATED(OutData%D2_32) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_32,1),SIZE(OutData%D2_32,2))); mask2 = .TRUE.
    OutData%D2_32 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_32))-1 ),mask2,OutData%D2_32)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_32)
  ENDIF
  IF ( ALLOCATED(OutData%D2_42) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_42,1),SIZE(OutData%D2_42,2))); mask2 = .TRUE.
    OutData%D2_42 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_42))-1 ),mask2,OutData%D2_42)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_42)
  ENDIF
  IF ( ALLOCATED(OutData%Cbar_21) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cbar_21,1),SIZE(OutData%Cbar_21,2))); mask2 = .TRUE.
    OutData%Cbar_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cbar_21))-1 ),mask2,OutData%Cbar_21)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cbar_21)
  ENDIF
  IF ( ALLOCATED(OutData%Cbar_22) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cbar_22,1),SIZE(OutData%Cbar_22,2))); mask2 = .TRUE.
    OutData%Cbar_22 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cbar_22))-1 ),mask2,OutData%Cbar_22)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cbar_22)
  ENDIF
  IF ( ALLOCATED(OutData%Dbar_13) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dbar_13,1),SIZE(OutData%Dbar_13,2))); mask2 = .TRUE.
    OutData%Dbar_13 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dbar_13))-1 ),mask2,OutData%Dbar_13)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dbar_13)
  ENDIF
  IF ( ALLOCATED(OutData%Dbar_23) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dbar_23,1),SIZE(OutData%Dbar_23,2))); mask2 = .TRUE.
    OutData%Dbar_23 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dbar_23))-1 ),mask2,OutData%Dbar_23)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dbar_23)
  ENDIF
  IF ( ALLOCATED(OutData%Dbar_24) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dbar_24,1),SIZE(OutData%Dbar_24,2))); mask2 = .TRUE.
    OutData%Dbar_24 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dbar_24))-1 ),mask2,OutData%Dbar_24)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dbar_24)
  ENDIF
  IF ( ALLOCATED(OutData%Fbar_21) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Fbar_21,1))); mask1 = .TRUE.
    OutData%Fbar_21 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fbar_21))-1 ),mask1,OutData%Fbar_21)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fbar_21)
  ENDIF
  IF ( ALLOCATED(OutData%MBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBB,1),SIZE(OutData%MBB,2))); mask2 = .TRUE.
    OutData%MBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBB))-1 ),mask2,OutData%MBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBB)
  ENDIF
  IF ( ALLOCATED(OutData%KBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%KBB,1),SIZE(OutData%KBB,2))); mask2 = .TRUE.
    OutData%KBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%KBB))-1 ),mask2,OutData%KBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%KBB)
  ENDIF
  IF ( ALLOCATED(OutData%MBM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBM,1),SIZE(OutData%MBM,2))); mask2 = .TRUE.
    OutData%MBM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBM))-1 ),mask2,OutData%MBM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBM)
  ENDIF
  IF ( ALLOCATED(OutData%PHI_R) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PHI_R,1),SIZE(OutData%PHI_R,2))); mask2 = .TRUE.
    OutData%PHI_R = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PHI_R))-1 ),mask2,OutData%PHI_R)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PHI_R)
  ENDIF
  IF ( ALLOCATED(OutData%PHI_M) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PHI_M,1),SIZE(OutData%PHI_M,2))); mask2 = .TRUE.
    OutData%PHI_M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PHI_M))-1 ),mask2,OutData%PHI_M)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PHI_M)
  ENDIF
  IF ( ALLOCATED(OutData%AM2InvJac) ) THEN
  ALLOCATE(mask2(SIZE(OutData%AM2InvJac,1),SIZE(OutData%AM2InvJac,2))); mask2 = .TRUE.
    OutData%AM2InvJac = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AM2InvJac))-1 ),mask2,OutData%AM2InvJac)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%AM2InvJac)
  ENDIF
  IF ( ALLOCATED(OutData%TI) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TI,1),SIZE(OutData%TI,2))); mask2 = .TRUE.
    OutData%TI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TI))-1 ),mask2,OutData%TI)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TI)
  ENDIF
  IF ( ALLOCATED(OutData%TIreact) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TIreact,1),SIZE(OutData%TIreact,2))); mask2 = .TRUE.
    OutData%TIreact = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TIreact))-1 ),mask2,OutData%TIreact)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TIreact)
  ENDIF
  OutData%NModes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Elems) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Elems,1),SIZE(OutData%Elems,2))); mask2 = .TRUE.
    OutData%Elems = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Elems))-1 ),mask2,OutData%Elems)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Elems)
  ENDIF
  OutData%qmL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%uL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_I = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_L = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_RbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofI = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofR = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofRbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofC = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NReact = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Reacts) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Reacts,1),SIZE(OutData%Reacts,2))); mask2 = .TRUE.
    OutData%Reacts = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Reacts))-1 ),mask2,OutData%Reacts)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Reacts)
  ENDIF
  OutData%Nmembers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TPdofL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%URbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%URdotdotL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UdotdotL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Y2L = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%IntMethod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NAvgEls = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%IDI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDI,1))); mask1 = .TRUE.
    OutData%IDI = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDI))-1 ),mask1,OutData%IDI)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDI)
  ENDIF
  IF ( ALLOCATED(OutData%IDR) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDR,1))); mask1 = .TRUE.
    OutData%IDR = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDR))-1 ),mask1,OutData%IDR)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDR)
  ENDIF
  IF ( ALLOCATED(OutData%IDL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDL,1))); mask1 = .TRUE.
    OutData%IDL = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDL))-1 ),mask1,OutData%IDL)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDL)
  ENDIF
  IF ( ALLOCATED(OutData%IDC) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDC,1))); mask1 = .TRUE.
    OutData%IDC = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDC))-1 ),mask1,OutData%IDC)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDC)
  ENDIF
  IF ( ALLOCATED(OutData%IDY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDY,1))); mask1 = .TRUE.
    OutData%IDY = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDY))-1 ),mask1,OutData%IDY)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDY)
  ENDIF
  OutData%NMOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%SDDeltaT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnJckF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%MoutLst,1), UBOUND(OutData%MoutLst,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    Re_MoutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    Db_MoutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    Int_MoutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg ) ! MoutLst 
ENDDO
DO i1 = LBOUND(OutData%MoutLst2,1), UBOUND(OutData%MoutLst2,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    Re_MoutLst2_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    Db_MoutLst2_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    Int_MoutLst2_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg ) ! MoutLst2 
ENDDO
DO i1 = LBOUND(OutData%MoutLst3,1), UBOUND(OutData%MoutLst3,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    Re_MoutLst3_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    Db_MoutLst3_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    Int_MoutLst3_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg ) ! MoutLst3 
ENDDO
DO i1 = LBOUND(OutData%ElemProps,1), UBOUND(OutData%ElemProps,1)
 ! first call SD_Packelemproptype to get correctly sized buffers for unpacking
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    Re_ElemProps_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    Db_ElemProps_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    Int_ElemProps_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  CALL SD_UnPackelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg ) ! ElemProps 
ENDDO
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call SD_Packoutvar_type to get correctly sized buffers for unpacking
  CALL SD_Packoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL SD_UnPackoutvar_type( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  OutData%OutAllInt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutAllDims = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutDec = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MaxOUtPts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackParam

 SUBROUTINE SD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(SD_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%TPMesh, DstInputData%TPMesh, CtrlCode, ErrStat, ErrMsg )
     CALL MeshCopy( SrcInputData%LMesh, DstInputData%LMesh, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopyInput

 SUBROUTINE SD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SD_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%TPMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%LMesh, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyInput

 SUBROUTINE SD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Db_TPMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Int_TPMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_TPMesh_Buf ) ! TPMesh
  IF(ALLOCATED(Re_TPMesh_Buf))  DEALLOCATE(Re_TPMesh_Buf)
  IF(ALLOCATED(Db_TPMesh_Buf))  DEALLOCATE(Db_TPMesh_Buf)
  IF(ALLOCATED(Int_TPMesh_Buf)) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Db_LMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Int_LMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LMesh_Buf ) ! LMesh
  IF(ALLOCATED(Re_LMesh_Buf))  DEALLOCATE(Re_LMesh_Buf)
  IF(ALLOCATED(Db_LMesh_Buf))  DEALLOCATE(Db_LMesh_Buf)
  IF(ALLOCATED(Int_LMesh_Buf)) DEALLOCATE(Int_LMesh_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 ) = Re_TPMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 ) = Db_TPMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 ) = Int_TPMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 ) = Re_LMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 ) = Db_LMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 ) = Int_LMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
 END SUBROUTINE SD_PackInput

 SUBROUTINE SD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    Re_TPMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    Db_TPMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    Int_TPMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg ) ! TPMesh 
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    Re_LMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    Db_LMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    Int_LMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg ) ! LMesh 
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInput

 SUBROUTINE SD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(SD_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcOutputData%Y1Mesh, DstOutputData%Y1Mesh, CtrlCode, ErrStat, ErrMsg )
     CALL MeshCopy( SrcOutputData%Y2Mesh, DstOutputData%Y2Mesh, CtrlCode, ErrStat, ErrMsg )
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT.ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'SD_CopyOutput: Error allocating DstOutputData%WriteOutput.'
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE SD_CopyOutput

 SUBROUTINE SD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SD_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%Y1Mesh, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%Y2Mesh, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE SD_DestroyOutput

 SUBROUTINE SD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y2Mesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Db_Y1Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Int_Y1Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y1Mesh_Buf ) ! Y1Mesh
  IF(ALLOCATED(Re_Y1Mesh_Buf))  DEALLOCATE(Re_Y1Mesh_Buf)
  IF(ALLOCATED(Db_Y1Mesh_Buf))  DEALLOCATE(Db_Y1Mesh_Buf)
  IF(ALLOCATED(Int_Y1Mesh_Buf)) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Db_Y2Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Int_Y2Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y2Mesh_Buf ) ! Y2Mesh
  IF(ALLOCATED(Re_Y2Mesh_Buf))  DEALLOCATE(Re_Y2Mesh_Buf)
  IF(ALLOCATED(Db_Y2Mesh_Buf))  DEALLOCATE(Db_Y2Mesh_Buf)
  IF(ALLOCATED(Int_Y2Mesh_Buf)) DEALLOCATE(Int_Y2Mesh_Buf)
  Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 ) = Re_Y1Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 ) = Db_Y1Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 ) = Int_Y1Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 ) = Re_Y2Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 ) = Db_Y2Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 ) = Int_Y2Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE SD_PackOutput

 SUBROUTINE SD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y2Mesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    Re_Y1Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    Db_Y1Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    Int_Y1Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg ) ! Y1Mesh 
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    Re_Y2Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    Db_Y2Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    Int_Y2Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg ) ! Y2Mesh 
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackOutput

 SUBROUTINE SD_CopydYdu( SrcdYduData, DstdYduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: SrcdYduData
   TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: DstdYduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdYduData%DummyOutput, DstdYduData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydYdu

 SUBROUTINE SD_DestroydYdu( dYduData, ErrStat, ErrMsg )
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: dYduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dYduData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydYdu

 SUBROUTINE SD_PackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialoutputpinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_PackdYdu

 SUBROUTINE SD_UnPackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdYdu

 SUBROUTINE SD_CopydXdu( SrcdXduData, DstdXduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: SrcdXduData
   TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: DstdXduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdXduData%DummyContState, DstdXduData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydXdu

 SUBROUTINE SD_DestroydXdu( dXduData, ErrStat, ErrMsg )
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: dXduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXduData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXdu

 SUBROUTINE SD_PackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialcontstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_PackdXdu

 SUBROUTINE SD_UnPackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdXdu

 SUBROUTINE SD_CopydXddu( SrcdXdduData, DstdXdduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: SrcdXdduData
   TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: DstdXdduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdXdduData%DummyDiscState, DstdXdduData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydXddu

 SUBROUTINE SD_DestroydXddu( dXdduData, ErrStat, ErrMsg )
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: dXdduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXdduData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXddu

 SUBROUTINE SD_PackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialdiscstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_PackdXddu

 SUBROUTINE SD_UnPackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdXddu

 SUBROUTINE SD_CopydZdu( SrcdZduData, DstdZduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: SrcdZduData
   TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: DstdZduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdZduData%DummyConstrState, DstdZduData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_CopydZdu

 SUBROUTINE SD_DestroydZdu( dZduData, ErrStat, ErrMsg )
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: dZduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dZduData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydZdu

 SUBROUTINE SD_PackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialconstrstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_PackdZdu

 SUBROUTINE SD_UnPackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdZdu

 SUBROUTINE SD_Copypartialoutputpcontstatetype( SrcpartialoutputpcontstatetypeData, DstpartialoutputpcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: SrcpartialoutputpcontstatetypeData
   TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: DstpartialoutputpcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialoutputpcontstatetypeData%DummyOutput, DstpartialoutputpcontstatetypeData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialoutputpcontstatetype

 SUBROUTINE SD_Destroypartialoutputpcontstatetype( partialoutputpcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: partialoutputpcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialoutputpcontstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpcontstatetype

 SUBROUTINE SD_Packpartialoutputpcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpcontstatetype

 SUBROUTINE SD_UnPackpartialoutputpcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialoutputpcontstatetype

 SUBROUTINE SD_Copypartialcontstatepcontstatetype( SrcpartialcontstatepcontstatetypeData, DstpartialcontstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: SrcpartialcontstatepcontstatetypeData
   TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: DstpartialcontstatepcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialcontstatepcontstatetypeData%DummyContState, DstpartialcontstatepcontstatetypeData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialcontstatepcontstatetype

 SUBROUTINE SD_Destroypartialcontstatepcontstatetype( partialcontstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: partialcontstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialcontstatepcontstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepcontstatetype

 SUBROUTINE SD_Packpartialcontstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepcontstatetype

 SUBROUTINE SD_UnPackpartialcontstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialcontstatepcontstatetype

 SUBROUTINE SD_Copypartialdiscstatepcontstatetype( SrcpartialdiscstatepcontstatetypeData, DstpartialdiscstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: SrcpartialdiscstatepcontstatetypeData
   TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: DstpartialdiscstatepcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialdiscstatepcontstatetypeData%DummyDiscState, DstpartialdiscstatepcontstatetypeData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialdiscstatepcontstatetype

 SUBROUTINE SD_Destroypartialdiscstatepcontstatetype( partialdiscstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: partialdiscstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialdiscstatepcontstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepcontstatetype

 SUBROUTINE SD_Packpartialdiscstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepcontstatetype

 SUBROUTINE SD_UnPackpartialdiscstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialdiscstatepcontstatetype

 SUBROUTINE SD_Copypartialconstrstatepcontstatetype( SrcpartialconstrstatepcontstatetypeData, DstpartialconstrstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: SrcpartialconstrstatepcontstatetypeData
   TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: DstpartialconstrstatepcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialconstrstatepcontstatetypeData%DummyConstrState, DstpartialconstrstatepcontstatetypeData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialconstrstatepcontstatetype

 SUBROUTINE SD_Destroypartialconstrstatepcontstatetype( partialconstrstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: partialconstrstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialconstrstatepcontstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepcontstatetype

 SUBROUTINE SD_Packpartialconstrstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepcontstatetype

 SUBROUTINE SD_UnPackpartialconstrstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialconstrstatepcontstatetype

 SUBROUTINE SD_Copypartialoutputpdiscstatetype( SrcpartialoutputpdiscstatetypeData, DstpartialoutputpdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: SrcpartialoutputpdiscstatetypeData
   TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: DstpartialoutputpdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialoutputpdiscstatetypeData%DummyOutput, DstpartialoutputpdiscstatetypeData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialoutputpdiscstatetype

 SUBROUTINE SD_Destroypartialoutputpdiscstatetype( partialoutputpdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: partialoutputpdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialoutputpdiscstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpdiscstatetype

 SUBROUTINE SD_Packpartialoutputpdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpdiscstatetype

 SUBROUTINE SD_UnPackpartialoutputpdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialoutputpdiscstatetype

 SUBROUTINE SD_Copypartialcontstatepdiscstatetype( SrcpartialcontstatepdiscstatetypeData, DstpartialcontstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: SrcpartialcontstatepdiscstatetypeData
   TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: DstpartialcontstatepdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialcontstatepdiscstatetypeData%DummyContState, DstpartialcontstatepdiscstatetypeData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialcontstatepdiscstatetype

 SUBROUTINE SD_Destroypartialcontstatepdiscstatetype( partialcontstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: partialcontstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialcontstatepdiscstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepdiscstatetype

 SUBROUTINE SD_Packpartialcontstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepdiscstatetype

 SUBROUTINE SD_UnPackpartialcontstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialcontstatepdiscstatetype

 SUBROUTINE SD_Copypartialdiscstatepdiscstatetype( SrcpartialdiscstatepdiscstatetypeData, DstpartialdiscstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: SrcpartialdiscstatepdiscstatetypeData
   TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: DstpartialdiscstatepdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialdiscstatepdiscstatetypeData%DummyDiscState, DstpartialdiscstatepdiscstatetypeData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialdiscstatepdiscstatetype

 SUBROUTINE SD_Destroypartialdiscstatepdiscstatetype( partialdiscstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: partialdiscstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialdiscstatepdiscstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepdiscstatetype

 SUBROUTINE SD_Packpartialdiscstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepdiscstatetype

 SUBROUTINE SD_UnPackpartialdiscstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialdiscstatepdiscstatetype

 SUBROUTINE SD_Copypartialconstrstatepdiscstatetype( SrcpartialconstrstatepdiscstatetypeData, DstpartialconstrstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: SrcpartialconstrstatepdiscstatetypeData
   TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: DstpartialconstrstatepdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialconstrstatepdiscstatetypeData%DummyConstrState, DstpartialconstrstatepdiscstatetypeData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialconstrstatepdiscstatetype

 SUBROUTINE SD_Destroypartialconstrstatepdiscstatetype( partialconstrstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: partialconstrstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialconstrstatepdiscstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepdiscstatetype

 SUBROUTINE SD_Packpartialconstrstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepdiscstatetype

 SUBROUTINE SD_UnPackpartialconstrstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialconstrstatepdiscstatetype

 SUBROUTINE SD_Copypartialoutputpconstrstatetype( SrcpartialoutputpconstrstatetypeData, DstpartialoutputpconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: SrcpartialoutputpconstrstatetypeData
   TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: DstpartialoutputpconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialoutputpconstrstatetypeData%DummyOutput, DstpartialoutputpconstrstatetypeData%DummyOutput, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialoutputpconstrstatetype

 SUBROUTINE SD_Destroypartialoutputpconstrstatetype( partialoutputpconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: partialoutputpconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialoutputpconstrstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpconstrstatetype

 SUBROUTINE SD_Packpartialoutputpconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpconstrstatetype

 SUBROUTINE SD_UnPackpartialoutputpconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialoutputpconstrstatetype

 SUBROUTINE SD_Copypartialcontstatepconstrstatetype( SrcpartialcontstatepconstrstatetypeData, DstpartialcontstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: SrcpartialcontstatepconstrstatetypeData
   TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: DstpartialcontstatepconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialcontstatepconstrstatetypeData%DummyContState, DstpartialcontstatepconstrstatetypeData%DummyContState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialcontstatepconstrstatetype

 SUBROUTINE SD_Destroypartialcontstatepconstrstatetype( partialcontstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: partialcontstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialcontstatepconstrstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepconstrstatetype

 SUBROUTINE SD_Packpartialcontstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepconstrstatetype

 SUBROUTINE SD_UnPackpartialcontstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialcontstatepconstrstatetype

 SUBROUTINE SD_Copypartialdiscstatepconstrstatetype( SrcpartialdiscstatepconstrstatetypeData, DstpartialdiscstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: SrcpartialdiscstatepconstrstatetypeData
   TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: DstpartialdiscstatepconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialdiscstatepconstrstatetypeData%DummyDiscState, DstpartialdiscstatepconstrstatetypeData%DummyDiscState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialdiscstatepconstrstatetype

 SUBROUTINE SD_Destroypartialdiscstatepconstrstatetype( partialdiscstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: partialdiscstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialdiscstatepconstrstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepconstrstatetype

 SUBROUTINE SD_Packpartialdiscstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepconstrstatetype

 SUBROUTINE SD_UnPackpartialdiscstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialdiscstatepconstrstatetype

 SUBROUTINE SD_Copypartialconstrstatepconstrstatetype( SrcpartialconstrstatepconstrstatetypeData, DstpartialconstrstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: SrcpartialconstrstatepconstrstatetypeData
   TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: DstpartialconstrstatepconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialconstrstatepconstrstatetypeData%DummyConstrState, DstpartialconstrstatepconstrstatetypeData%DummyConstrState, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE SD_Copypartialconstrstatepconstrstatetype

 SUBROUTINE SD_Destroypartialconstrstatepconstrstatetype( partialconstrstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: partialconstrstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialconstrstatepconstrstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepconstrstatetype

 SUBROUTINE SD_Packpartialconstrstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepconstrstatetype

 SUBROUTINE SD_UnPackpartialconstrstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialconstrstatepconstrstatetype

 SUBROUTINE SD_Pack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg, &
                     SizeOnly )
  TYPE(SD_InputType),           INTENT(INOUT) :: InData
  TYPE(SD_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(SD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(SD_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(SD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(SD_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(SD_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(  OUT) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(  OUT) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,  INTENT(  OUT) :: Int_RetAry(:)
  INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
  CHARACTER(*),                 INTENT(  OUT) :: ErrMsg
  LOGICAL, OPTIONAL,            INTENT(IN   ) :: SizeOnly
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  LOGICAL                                :: OnlySize ! if present and true, do not pack, just allocate buffers
    ! Executable statements
  ErrStat = ErrID_None
  ErrMsg  = ""
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred  = Re_Xferred - 1
  Db_Xferred  = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
  IF ( ALLOCATED( Re_RetAry ) ) DEALLOCATE( Re_RetAry ) ;
  IF ( Re_Xferred .GT. 0) ALLOCATE( Re_RetAry( Re_Xferred ) ) ;
  IF ( ALLOCATED( Db_RetAry ) ) DEALLOCATE( Db_RetAry ) ;
  IF ( Db_Xferred .GT. 0) ALLOCATE( Db_RetAry( Db_Xferred ) ) ;
  IF ( ALLOCATED( Int_RetAry ) ) DEALLOCATE( Int_RetAry ) ;
  IF ( Int_Xferred .GT. 0) ALLOCATE( Int_RetAry( Int_Xferred ) ) ;
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred   = Re_Xferred - 1
  Db_Xferred   = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
 END SUBROUTINE SD_Pack

 SUBROUTINE SD_UnPack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg )
  TYPE(SD_InputType),           INTENT(INOUT) :: InData
  TYPE(SD_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(SD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(SD_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(SD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(SD_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(SD_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(IN   ) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(IN   ) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,   INTENT(IN   ) :: Int_RetAry(:)
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! UnPack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnPackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnPackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnPackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnPackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnPackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnPackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! UnPack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL SD_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL SD_UnPackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPack


 SUBROUTINE SD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%TPMesh, u_out%TPMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%LMesh, u_out%LMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%TPMesh, u(2)%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp1(u(1)%LMesh, u(2)%LMesh, tin, u_out%LMesh, tin_out, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%TPMesh, u(2)%TPMesh, u(3)%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp2(u(1)%LMesh, u(2)%LMesh, u(3)%LMesh, tin, u_out%LMesh, tin_out, ErrStat, ErrMsg )
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Input_ExtrapInterp


 SUBROUTINE SD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%Y1Mesh, u_out%Y1Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%Y2Mesh, u_out%Y2Mesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%Y1Mesh, u(2)%Y1Mesh, tin, u_out%Y1Mesh, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp1(u(1)%Y2Mesh, u(2)%Y2Mesh, tin, u_out%Y2Mesh, tin_out, ErrStat, ErrMsg )
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%Y1Mesh, u(2)%Y1Mesh, u(3)%Y1Mesh, tin, u_out%Y1Mesh, tin_out, ErrStat, ErrMsg )
  CALL MeshExtrapInterp2(u(1)%Y2Mesh, u(2)%Y2Mesh, u(3)%Y2Mesh, tin, u_out%Y2Mesh, tin_out, ErrStat, ErrMsg )
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Output_ExtrapInterp

END MODULE SubDyn_Types
!ENDOFREGISTRYGENERATEDFILE
